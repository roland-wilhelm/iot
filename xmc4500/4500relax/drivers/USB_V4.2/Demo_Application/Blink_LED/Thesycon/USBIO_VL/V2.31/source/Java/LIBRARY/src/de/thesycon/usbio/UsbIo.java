package de.thesycon.usbio;

import de.thesycon.usbio.structs.*;

/**
 * This class implements the interface to the USBIO device driver.
 * It contains only general device-related functions that can be executed
 * without a pipe context.
 * Pipe specific functions are implemented by the UsbIoPipe class.
 *
 * @author Thesycon
 * @version 2.0
 */
public class UsbIo implements UsbIoErrorCodes, UsbIoInterface, UsbSpec

{


	// internal

	protected HANDLE Handle;

	// UsbIo

	/**
	 * Creates an internal device list.
	 * <p>
	 * The function creates a windows-internal device list that contains all matching interfaces.
	 * The device interface is identified by InterfaceGuid. A handle for the list
	 * is returned in case of success, or 0 is returned in case of error.
	 * The device list can be iterated by means of Open.
	 * <p>
	 * The device list returned must be freed by a call to DestroyDeviceList.
	 * <p>
	 * Note that CreateDeviceList is declared static.
	 * It can be used independently of class instances.
	 *
	 * @param InterfaceGuid This is the predefined interface GUID of the USBIO device driver or a user defined
	 * GUID which must be inserted in the USBIO.INF file.
	 *
	 * @return Returns a handle to the device list if successful, or 0 otherwise.
	 *
     * @see de.thesycon.usbio.UsbIo#open(int, int, String)
     * @see de.thesycon.usbio.UsbIo#destroyDeviceList(int)
	*/
	public static native int createDeviceList(String InterfaceGuid);

	private native int open(HANDLE Handle, int DeviceNumber, int DeviceList, String InterfaceGuid);

	private native void close(HANDLE Handle);

	private native int acquireDevice(HANDLE Handle);

	private native int releaseDevice(HANDLE Handle);

	/**
	 * Destroy the internal device list.
	 * <p>
	 * Use this function to destroy a device list that was generated by a call to CreateDeviceList.
	 * <p>
	 * Note that DestroyDeviceList is declared static.
	 * It can be used independently of class instances.
	 *
	 * @param DeviceList A handle to a device list returned by CreateDeviceList.
	 *
     * @see de.thesycon.usbio.UsbIo#createDeviceList(String)
	*/
	public static native void destroyDeviceList(int DeviceList);

	private native int getDescriptor(HANDLE Handle, byte[] data, int[] bytecount, int Recipient, byte DescriptorType, byte DescriptorIndex, short LanguageId);

	private native int setDescriptor(HANDLE Handle, byte[] data, int[] bytecount, int Recipient, byte DescriptorType, byte DescriptorIndex, short LanguageId);

	private native int getStringDescriptor(HANDLE Handle, byte[] data,int[] bytecount, byte Index, int LanguageId);

	private native int getConfigurationDescriptor(HANDLE Handle, byte[] data,int[] bytecount, byte Index);

	private native int getDeviceDescriptor(HANDLE Handle, byte[] data);

	private native int getDeviceParameters(HANDLE Handle, byte[] data);

	private native int setDeviceParameters(HANDLE Handle, byte[] data);

	private native int getDriverInfo(HANDLE Handle, byte[] data);

	private native int setConfiguration(HANDLE Handle, byte[] data);

	private native int getConfiguration(HANDLE Handle, byte[] data);

	private native int getConfigurationInfo(HANDLE Handle, byte[] data);

	private native int unconfigureDevice(HANDLE Handle);

	private native int getDeviceInfo(HANDLE Handle, byte[] data);

	private native int getInterface(HANDLE Handle, byte[] AlternateSetting, short Interface);

	private native int setInterface(HANDLE Handle, byte[] data);

	private native int clearFeature(HANDLE Handle, int Recipient, short FeatureSelector, short Index);

	private native int setFeature(HANDLE Handle, int Recipient, short FeatureSelector, short Index);

	private native int cyclePort(HANDLE Handle);

	private native int resetDevice(HANDLE Handle);

	private native int getCurrentFrameNumber(HANDLE Handle, int[] FrameNumber);

	private native int getStatus(HANDLE Handle, short[] Status, int Recipient, short Index);

	private native int getDevicePowerState(HANDLE Handle, int[] DevicePowerState);

	private native int setDevicePowerState(HANDLE Handle, int DevicePowerState);

	private native int classOrVendorInRequest(HANDLE Handle, byte[] data, int[] count, byte[] Request);

	private native int classOrVendorOutRequest(HANDLE Handle, byte[] data, int[] count, byte[] Request);

	private native int getBandwidthInfo(HANDLE Handle, byte[] data);

	/**
	 * Translate an USBIO error code to a description string.
	 * <p>
	 * This function supports private USBIO error codes only.
	 * These codes start with a prefix of 0xE.
	 * The function cannot be used to translate general Windows error codes.
	 * <p>
	 * Note that ErrorText is declared static.
	 * It can be used independently of class instances.
	 *
	 * @param ErrorCode The error code to be translated.
	 *
	 * @return The function returns a String with the error text.
	*/
	public static native String errorText(int ErrorCode);

	private native boolean isCheckedBuild(HANDLE Handle);

	private native boolean isDemoVersion(HANDLE Handle);

	private native boolean isLightVersion(HANDLE Handle);

	private native boolean isOperatingAtHighSpeed(HANDLE Handle);

	private native boolean isOpen(HANDLE Handle);


	// load dll

	static {
		System.loadLibrary("USBIOJAVA");
	}

    /**
     * Returns <code>true</code> if the class instance is attached to a device.
     *
     * @return <code>true</code> if the class instance is attached to a device, <code>false</code> otherwise.
     *
     * @see de.thesycon.usbio.UsbIo#open(int, int, String)
     * @see de.thesycon.usbio.UsbIo#close()
     */
	public boolean isOpen() {
		return isOpen(Handle);
	}

    /**
     * Returns <code>true</code> if the USB 2.0 device is operating at high speed (480 Mbit/s).
     * <p>
	 * If this function returns <code>true</code> then the USB device operates in high speed mode.
	 * The USB 2.0 device is connected to a hub port that is high speed capable.
	 * <p>
	 * Note that this function does not indicate whether a device is capable of high speed
	 * operation, but rather whether it is in fact operating at high speed.
	 * <p>
	 * This function calls {@link de.thesycon.usbio.UsbIo#getDeviceInfo(USBIO_DEVICE_INFO) getDeviceInfo} to get the requested information.
	 * <p>
	 * The device must have been opened before this function is called.
     *
     * @return <code>true</code> if the USB device is operating at high speed, <code>false</code> otherwise.
     *
     * @see de.thesycon.usbio.UsbIo#open(int, int, String)
     * @see de.thesycon.usbio.UsbIo#getDeviceInfo(USBIO_DEVICE_INFO)
     */
	public boolean isOperatingAtHighSpeed() {
		return isOperatingAtHighSpeed(Handle);
	}

    /**
     * Returns <code>true</code> if a checked build (debug version) of the USBIO driver was detected.
     * <p>
	 * The device must have been opened before this function is called.
     *
     * @return <code>true</code> if the checked build of the USBIO driver is running, <code>false</code> otherwise.
     *
     * @see de.thesycon.usbio.UsbIo#open(int, int, String)
     * @see de.thesycon.usbio.UsbIo#isDemoVersion()
     * @see de.thesycon.usbio.UsbIo#isLightVersion()
     */
	public boolean isCheckedBuild() {
		return isCheckedBuild(Handle);
	}

    /**
     * Returns <code>true</code> if the Demo version of the USBIO driver was detected.
     * <p>
	 * The device must have been opened before this function is called.
     *
     * @return <code>true</code> if the Demo version of the USBIO driver is running, <code>false</code> otherwise.
     *
     * @see de.thesycon.usbio.UsbIo#open(int, int, String)
     * @see de.thesycon.usbio.UsbIo#isCheckedBuild()
     * @see de.thesycon.usbio.UsbIo#isLightVersion()
     */
	public boolean isDemoVersion() {
		return isDemoVersion(Handle);
	}

    /**
     * Returns <code>true</code> if the Light version of the USBIO driver was detected.
     * <p>
	 * The device must have been opened before this function is called.
     *
     * @return <code>true</code> if the Light version of the USBIO driver is running, <code>false</code> otherwise.
     *
     * @see de.thesycon.usbio.UsbIo#open(int, int, String)
     * @see de.thesycon.usbio.UsbIo#isCheckedBuild()
     * @see de.thesycon.usbio.UsbIo#isDemoVersion()
     */
	public boolean isLightVersion() {
		return isLightVersion(Handle);
	}

	/**
	 * Open an USB device.
	 *
	 * @param DeviceNumber Specifies the index number of the USB Device.
	 * The index is zero-based.
	 * Note that the association between this number and the USB device
	 * can change with each call to CreateDeviceList.
	 *
	 * @param DeviceList A handle to the internal device list which was returned by the function
	 * CreateDeviceList or 0.
	 *
	 * @param InterfaceGuid The specified GUID is the predefined interface GUID of the USBIO device driver,
	 * or a user-defined GUID which has to be defined in the USBIO.INF file.
	 * This parameter will be ignored if DeviceList is set to NULL.
	 * For more information, see below.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#createDeviceList(String)
	 * @see de.thesycon.usbio.UsbIo#destroyDeviceList(int)
	 * @see de.thesycon.usbio.UsbIo#close()
	 * @see de.thesycon.usbio.UsbIo#isOpen()
	 * @see de.thesycon.usbio.UsbIo#isCheckedBuild()
	 * @see de.thesycon.usbio.UsbIo#isDemoVersion()
	 * @see de.thesycon.usbio.UsbIo#isLightVersion()
	*/
	public int open(int DeviceNumber, int DeviceList, String InterfaceGuid) {
		if (Handle.getHANDLE() != 0) {
			close();
		}
		return open(Handle, DeviceNumber,DeviceList,InterfaceGuid);
	}

	/**
	 * Standard constructor of the UsbIo class.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 */
	public UsbIo() {
		Handle = new HANDLE();
		Handle.setHANDLE(0);
	}

	/**
	 * Close the USB device.
	 * <p>
	 * This function can be called if the device is not open. It does nothing in this case.
	 * <p>
	 * Any thread associated with the class instance should have been stopped
	 * before this function is called. See {@link de.thesycon.usbio.UsbIoThread#shutdownThread() shutdownThread}.
	 *
	 * @see de.thesycon.usbio.UsbIo#createDeviceList(String)
	 * @see de.thesycon.usbio.UsbIo#destroyDeviceList(int)
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIoThread#shutdownThread()
	*/
	public void close() {
		if (Handle.getHANDLE() != 0) {
			close(Handle);
			Handle.setHANDLE(0);
		}
	}



	/**
	 * Acquire the USB device for exclusive use.
	 * <p>
	 * If the function returns with success, no other process can open the same device.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#releaseDevice()
	*/
	public int acquireDevice() {
		return acquireDevice(Handle);
	}



	/**
	 * Release the USB device. 
	 * <p>
	 * If the function returns with success, other processes can open the device.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#acquireDevice()
	*/
	public int releaseDevice() {
		return releaseDevice(Handle);
	}


	/**
	 * Get information on the current USB bandwidth consumption.
	 * <p>
	 * The function enables an application to check the bandwidth that is available on the USB.
	 * Depending on this information an application can select an appropriate
	 * device configuration, if desired.
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_GET_BANDWIDTH_INFO operation.
	 *
	 * @param BandwidthInfo Reference to a caller-provided variable.
	 * The structure returns information on the bandwidth that is available on the USB.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.structs.USBIO_BANDWIDTH_INFO#USBIO_BANDWIDTH_INFO
	*/
	public int getBandwidthInfo(USBIO_BANDWIDTH_INFO BandwidthInfo) {
		if (BandwidthInfo == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		byte[] data = BandwidthInfo.buildByteArray();
		int Status = getBandwidthInfo(Handle, data);
		BandwidthInfo.parseByteArray(data);
		return Status;
	}

	/**
	 * Get information about the USB device.
	 * <p>
	 * This function can be used to detect if the device operates in high speed mode.
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_GET_DEVICE_INFO operation.
	 *
	 * @param DeviceInfo Reference to a caller-provided variable.
	 * The structure returns information on the USB device.
	 * This includes a flag that indicates whether the device operates in
	 * high speed mode or not.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.structs.USBIO_DEVICE_INFO#USBIO_DEVICE_INFO
	*/
	public int getDeviceInfo(USBIO_DEVICE_INFO DeviceInfo) {
		if (DeviceInfo == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		byte[] data = DeviceInfo.buildByteArray();
		int Status = getDeviceInfo(Handle, data);
		DeviceInfo.parseByteArray(data);
		return Status;
	}

	/**
	 * Sends a class or vendor specific request with a data phase in device to host (IN) direction.
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_CLASS_OR_VENDOR_IN_REQUEST operation.
	 *
	 * @param BufDesc Reference to a caller-provided buffer descriptor.
	 * The buffer receives the data transferred in the IN data phase.
	 * When the function is called the buffer descriptor specifies the size, in bytes, of the
	 * buffer.
	 * After the function successfully returned the buffer descriptor contains
	 * the number of valid bytes returned in the buffer.
	 *
	 * @param Request Reference to a caller-provided variable that defines the request to be generated.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#classOrVendorOutRequest(USBIO_DATA_BUFFER, USBIO_CLASS_OR_VENDOR_REQUEST)
	 * @see de.thesycon.usbio.structs.USBIO_CLASS_OR_VENDOR_REQUEST#USBIO_CLASS_OR_VENDOR_REQUEST
	*/
	public int classOrVendorInRequest(USBIO_DATA_BUFFER BufDesc, USBIO_CLASS_OR_VENDOR_REQUEST Request) {
		if (BufDesc == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		if (BufDesc.Buffer() == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		if (Request == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		byte[] req = Request.buildByteArray();
		int[] bytecount = new int[1];
		bytecount[0] = BufDesc.getNumberOfBytesToTransfer();
		int Status = classOrVendorInRequest(Handle, BufDesc.Buffer(), bytecount, req);
		BufDesc.setBytesTransferred(bytecount[0]);
		Request.parseByteArray(req);
		return Status;
	}

	/**
	 * Sends a class or vendor specific request with a data phase in host to device (OUT) direction.
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_CLASS_OR_VENDOR_OUT_REQUEST operation.
	 *
	 * @param BufDesc Reference to a caller-provided buffer descriptor.
	 * The buffer receives the data transferred in the IN data phase.
	 * When the function is called the buffer descriptor specifies the size, in bytes, of the
	 * buffer.
	 * After the function successfully returned the buffer descriptor contains
	 * the number of bytes transferred.
	 *
	 * @param Request Reference to a caller-provided variable that defines the request to be generated.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#classOrVendorInRequest(USBIO_DATA_BUFFER, USBIO_CLASS_OR_VENDOR_REQUEST)
	 * @see de.thesycon.usbio.structs.USBIO_CLASS_OR_VENDOR_REQUEST#USBIO_CLASS_OR_VENDOR_REQUEST
	*/
	public int classOrVendorOutRequest(USBIO_DATA_BUFFER BufDesc, USBIO_CLASS_OR_VENDOR_REQUEST Request) {
		if (BufDesc == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		if (BufDesc.Buffer() == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		if (Request == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		byte[] req = Request.buildByteArray();
		int[] bytecount = new int[1];
		bytecount[0] = BufDesc.getNumberOfBytesToTransfer();
		int Status = classOrVendorOutRequest(Handle, BufDesc.Buffer(), bytecount, req);
		BufDesc.setBytesTransferred(bytecount[0]);
		Request.parseByteArray(req);
		return Status;
	}

	/**
	 * Simulates a device disconnect/connect cycle.
	 * <p>
	 * This function causes a device disconnect/connect cycle and
	 * an unload/load cycle for the USBIO device driver as well.
	 * <p>
	 * Note: CyclePort does not work on multi-interface devices
	 * (see also problems.txt in the USBIO package).
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_CYCLE_PORT operation.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#resetDevice()
	*/
	public int cyclePort() {
		return cyclePort(Handle);
	}

	/**
	 * Force an USB reset.
	 * <p>
	 * This function causes an USB reset to be issued on the hub port the device
	 * is connected to.
	 * This will abort all pending read and write requests and unbind all pipes.
	 * The device will be set to the unconfigured state.
	 * <p>
	 * Note: The device must be in the configured state when this function
	 * is called.
	 * ResetDevice does not work when the system-provided USB multi-interface driver
	 * is used (see also problems.txt in the USBIO package).
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_RESET_DEVICE operation.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#setConfiguration(USBIO_SET_CONFIGURATION)
	 * @see de.thesycon.usbio.UsbIo#unconfigureDevice()
	 * @see de.thesycon.usbio.UsbIo#cyclePort()
	 * @see de.thesycon.usbio.UsbIoPipe#bind(int, byte, int, String)
	 * @see de.thesycon.usbio.UsbIoPipe#unbind()
	 * @see de.thesycon.usbio.UsbIoPipe#abortPipe()
	*/
	public int resetDevice() {
		return resetDevice(Handle);
	}

	/**
	 * Get the current USB frame number from the host controller.
	 * <p>
	 * The returned frame number is a 32 bit value.
	 * The 11 least significant bits correspond to the frame
	 * number in the USB frame token.
	 * <p>
	 * The device must have been opened and configured before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_GET_CURRENT_FRAME_NUMBER operation.
	 *
	 * @param FrameNumber If the function call is successful this variable returns the
	 * current frame number.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	*/
	public int getCurrentFrameNumber(int[] FrameNumber) {
		if (FrameNumber == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		return getCurrentFrameNumber(Handle, FrameNumber);
	}

	/**
	 * Send a get status request to the USB device.
	 * <p>
	 * The device must have been opened and configured before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_GET_STATUS operation.
	 *
	 * @param StatusValue If the function call is successful this variable returns the
	 * 16-bit value that is returned by the recipient in response to the
	 * get status request.
	 * The interpretation of the value is specific to the recipient.
	 * Refer to the USB specification.
	 *
	 * @param Recipient Specifies the recipient of the request.
	 *
	 * @param Index Specifies the index value for the get status request.
	 * The values are defined by the device.
	 * Refer to the USB specification.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#setFeature(int, short, short)
	 * @see de.thesycon.usbio.UsbIo#clearFeature(int, short, short)
	*/
	public int getStatus(short[] StatusValue, int Recipient, short Index) {
		if (StatusValue == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		return getStatus(Handle, StatusValue, Recipient, Index);
	}

	/**
	 * This function returns the active alternate setting of an interface.
	 * <p>
	 * The device must have been opened and configured before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_GET_INTERFACE operation.
	 *
	 * @param AlternateSetting If the function call is successful this variable returns the
	 * current alternate setting of the interface.
	 *
	 * @param Interface Specifies the index of the interface to be queried.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#setConfiguration(USBIO_SET_CONFIGURATION)
	 * @see de.thesycon.usbio.UsbIo#setInterface(USBIO_INTERFACE_SETTING)
	*/
	public int getInterface(byte[] AlternateSetting, short Interface) {
		if (AlternateSetting == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		return getInterface(Handle, AlternateSetting, Interface);
	}

	/**
	 * This function changes the alternate setting of an interface.
	 * <p>
	 * The device must have been opened and configured before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_SET_INTERFACE operation.
	 *
	 * @param InterfaceSetting Reference to a caller-provided structure that specifies the
	 * interface and the alternate settings to be set.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#setConfiguration(USBIO_SET_CONFIGURATION)
	 * @see de.thesycon.usbio.UsbIo#getInterface(byte[], short)
	 * @see de.thesycon.usbio.structs.USBIO_INTERFACE_SETTING#USBIO_INTERFACE_SETTING
	*/
	public int setInterface(USBIO_INTERFACE_SETTING InterfaceSetting) {
		if (InterfaceSetting == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		byte[] data = InterfaceSetting.buildByteArray();
		int Status =  setInterface(Handle, data);
		InterfaceSetting.parseByteArray(data);
		return Status;
	}

	/**
	 * Returns the current device power state.
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_GET_DEVICE_POWER_STATE operation.
	 *
	 * @param DevicePowerState If the function call is successful this variable returns the
	 * current device power state.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#setDevicePowerState(int)
	*/
	public int getDevicePowerState(int[] DevicePowerState) {
		if (DevicePowerState == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		return getDevicePowerState(Handle, DevicePowerState);
	}

	/**
	 * Set the device power state.
	 * <p>
	 * In order to set the device to suspend it must be in the configured state.
	 * <p>
	 * When the device is set to suspend all pending read and write requests will
	 * be returned by the USBIO driver with an error status of USBIO_ERR_POWER_DOWN.
	 * An application can ignore this error status and submit the requests to the
	 * driver again.
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_SET_DEVICE_POWER_STATE operation.
	 *
	 * @param DevicePowerState If the function call is successful this variable returns the
	 * current device power state.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#getDevicePowerState(int[])
	*/
	public int setDevicePowerState(int DevicePowerState) {
		return setDevicePowerState(Handle, DevicePowerState);
	}

	/**
	 * Send a clear feature request to the USB device.
	 * <p>
	 * In order to set the device to suspend it must be in the configured state.
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_CLEAR_FEATURE operation.
	 *
	 * @param Recipient Specifies the recipient of the request.
	 *
	 * @param FeatureSelector Specifies the feature selector value for the request.
	 * The values are defined by the recipient. Refer to the USB specification.
	 *
	 * @param Index Specifies the index value for the set feature request.
	 * The values are defined by the device. Refer to the USB specification.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#setFeature(int, short, short)
	 * @see de.thesycon.usbio.UsbIo#getStatus(short[], int, short)
	*/
	public int clearFeature(int Recipient, short FeatureSelector, short Index) {
		return clearFeature(Handle, Recipient, FeatureSelector, Index);
	}

	/**
	 * Send a set feature request to the USB device.
	 * <p>
	 * In order to set the device to suspend it must be in the configured state.
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_SET_FEATURE operation.
	 *
	 * @param Recipient Specifies the recipient of the request.
	 *
	 * @param FeatureSelector Specifies the feature selector value for the request.
	 * The values are defined by the recipient. Refer to the USB specification.
	 *
	 * @param Index Specifies the index value for the set feature request.
	 * The values are defined by the device. Refer to the USB specification.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#clearFeature(int, short, short)
	 * @see de.thesycon.usbio.UsbIo#getStatus(short[], int, short)
	*/
	public int setFeature(int Recipient, short FeatureSelector, short Index) {
		return setFeature(Handle, Recipient, FeatureSelector, Index);
	}

	/**
	 * Get a descriptor from the device.
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_GET_DESCRIPTOR operation.
	 *
	 * @param BufDesc Reference to a caller-provided buffer descriptor.
	 * The buffer receives the requested descriptor.
	 * When the function is called the buffer descriptor specifies the size, in bytes, of the
	 * buffer.
	 * After the function successfully returned the buffer descriptor contains
	 * the number of valid bytes returned in the buffer.
	 *
	 * @param Recipient Specifies the recipient of the request.
	 *
	 * @param DescriptorType The type of the descriptor to request.
	 *
	 * @param DescriptorIndex The index of the descriptor to request.
	 *
	 * @param LanguageId The language ID of the descriptor to request.
	 * Used for string descriptors only.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#getDeviceDescriptor(USB_DEVICE_DESCRIPTOR)
	 * @see de.thesycon.usbio.UsbIo#getConfigurationDescriptor(USBIO_DATA_BUFFER, byte)
	 * @see de.thesycon.usbio.UsbIo#getStringDescriptor(USB_STRING_DESCRIPTOR, byte, int)
	 * @see de.thesycon.usbio.UsbIo#setDescriptor(USBIO_DATA_BUFFER, int, byte, byte, short)
	*/
	public int getDescriptor(USBIO_DATA_BUFFER BufDesc, int Recipient, byte DescriptorType, byte DescriptorIndex, short LanguageId) {
		if (BufDesc == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		if (BufDesc.Buffer() == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		int[] bytecount = new int[1];
		bytecount[0] = BufDesc.getNumberOfBytesToTransfer();
		int Status = getDescriptor(Handle, BufDesc.Buffer(), bytecount, Recipient, DescriptorType, DescriptorIndex, LanguageId);
		BufDesc.setBytesTransferred(bytecount[0]);
		return Status;
	}

	/**
	 * Get a descriptor from the device.
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_GET_DESCRIPTOR operation.
	 *
	 * @param BufDesc Reference to a caller-provided buffer descriptor.
	 * The buffer receives the requested descriptor.
	 * When the function is called the buffer descriptor specifies the size, in bytes, of the
	 * buffer.
	 * After the function successfully returned the buffer descriptor contains
	 * the number of valid bytes returned in the buffer.
	 *
	 * @param Recipient Specifies the recipient of the request.
	 *
	 * @param DescriptorType The type of the descriptor to request.
	 *
	 * @param DescriptorIndex The index of the descriptor to request.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#getDeviceDescriptor(USB_DEVICE_DESCRIPTOR)
	 * @see de.thesycon.usbio.UsbIo#getConfigurationDescriptor(USBIO_DATA_BUFFER, byte)
	 * @see de.thesycon.usbio.UsbIo#getStringDescriptor(USB_STRING_DESCRIPTOR, byte, int)
	 * @see de.thesycon.usbio.UsbIo#setDescriptor(USBIO_DATA_BUFFER, int, byte, byte, short)
	*/
	public int getDescriptor(USBIO_DATA_BUFFER BufDesc, int Recipient, byte DescriptorType, byte DescriptorIndex) {
		return getDescriptor(BufDesc, Recipient, DescriptorType, DescriptorIndex, (short)0);
	}

	/**
	 * Set a descriptor of the device.
	 * <p>
	 * Note that most devices do not support the set descriptor request.
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_SET_DESCRIPTOR operation.
	 *
	 * @param BufDesc Reference to a caller-provided buffer descriptor.
	 * The buffer contains the descriptor data to be set.
	 * When the function is called the buffer descriptor specifies the size, in bytes, of the
	 * buffer.
	 * After the function successfully returned the buffer descriptor contains
	 * the number of bytes transferred.
	 *
	 * @param Recipient Specifies the recipient of the request.
	 *
	 * @param DescriptorType The type of the descriptor to set.
	 *
	 * @param DescriptorIndex The index of the descriptor to set.
	 *
	 * @param LanguageId The language ID of the descriptor to set.
	 * Used for string descriptors only.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#getDescriptor(USBIO_DATA_BUFFER, int, byte, byte)
	 * @see de.thesycon.usbio.UsbIo#getDeviceDescriptor(USB_DEVICE_DESCRIPTOR)
	 * @see de.thesycon.usbio.UsbIo#getConfigurationDescriptor(USBIO_DATA_BUFFER, byte)
	 * @see de.thesycon.usbio.UsbIo#getStringDescriptor(USB_STRING_DESCRIPTOR, byte, int)
	*/
	public int setDescriptor(USBIO_DATA_BUFFER BufDesc, int Recipient, byte DescriptorType, byte DescriptorIndex, short LanguageId) {
		if (BufDesc == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		if (BufDesc.Buffer() == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		int[] bytecount = new int[1];
		bytecount[0] = BufDesc.getNumberOfBytesToTransfer();
		int Status = setDescriptor(Handle, BufDesc.Buffer(), bytecount, Recipient, DescriptorType, DescriptorIndex, LanguageId);
		BufDesc.setBytesTransferred(bytecount[0]);
		return Status;
	}

	/**
	 * Get a string descriptor from the device.
	 * <p>
	 * GetStringDescriptor calls GetDescriptor to retrieve the descriptor.
	 * Thus, for detailed information see also GetDescriptor.
	 * <p>
	 * If this function is called with Index set to 0 the device returns a
	 * list of language IDs it supports.
	 * An application can select the correct language ID and use it
	 * in subsequent calls to this function.
	 * <p>
	 * The device must have been opened before this function is called.
	 *
	 * @param Desc Reference to a caller-provided buffer that receives the requested descriptor.
	 * Note that according to the USB specification the maximum size of a string
	 * descriptor is 256 bytes.
	 *
	 * @param Index The index of the descriptor to request.
	 * Set to 0 to retrieve a list of supported language IDs.
	 *
	 * @param LanguageId The language ID of the string descriptor to request.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#getDescriptor(USBIO_DATA_BUFFER, int, byte, byte)
	 * @see de.thesycon.usbio.UsbIo#getConfigurationDescriptor(USBIO_DATA_BUFFER, byte)
	 * @see de.thesycon.usbio.UsbIo#getDeviceDescriptor(USB_DEVICE_DESCRIPTOR)
	*/
	public int getStringDescriptor(USB_STRING_DESCRIPTOR Desc,byte Index, int LanguageId) {
		if (Desc == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		byte[] Buffer = new byte[USB_STRING_DESCRIPTOR.MAX_DESCRIPTOR_BUFFER_SIZE];
		int[] bytecount = new int[]{USB_STRING_DESCRIPTOR.MAX_DESCRIPTOR_BUFFER_SIZE};
		int Status = getStringDescriptor(Handle, Buffer, bytecount, Index, LanguageId);
		Desc.parseByteArray(Buffer,bytecount[0]);
		return Status;
	}

	/**
	 * Get a configuration descriptor from the device.
	 * <p>
	 * GetConfigurationDescriptor calls GetDescriptor to retrieve the descriptor.
	 * Thus, for detailed information see also GetDescriptor.
	 * <p>
	 * If the total size of the configuration descriptor is not known
	 * it can be retrieved in a two step process.
	 * With a first call to this function the fixed part of the descriptor
	 * which is defined by USB_CONFIGURATION_DESCRIPTOR is retrieved.
	 * The total size of the descriptor is indicated by the wTotalLength
	 * field of the structure.
	 * In a second step a buffer of the required size can be allocated and the
	 * complete descriptor can be retrieved with another call to this function.
	 * <p>
	 * The device must have been opened before this function is called.
	 *
	 * @param BufDesc Reference to a caller-provided buffer descriptor that receives the requested descriptor.
	 * Note that the size of the configuration descriptor depends on the USB device.
	 * See also the comments below.
	 * When the function is called the buffer descriptor specifies the size, in bytes, of the
	 * buffer.
	 * After the function successfully returned the buffer descriptor contains
	 * the number of valid bytes returned in the buffer.
	 *
	 * @param Index The index of the descriptor to request.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#getDescriptor(USBIO_DATA_BUFFER, int, byte, byte)
	 * @see de.thesycon.usbio.UsbIo#getStringDescriptor(USB_STRING_DESCRIPTOR, byte, int)
	 * @see de.thesycon.usbio.UsbIo#getDeviceDescriptor(USB_DEVICE_DESCRIPTOR)
	*/
	public int getConfigurationDescriptor(USBIO_DATA_BUFFER BufDesc, byte Index) {
		if (BufDesc == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		if (BufDesc.Buffer() == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		int[] bytecount = new int[1];
		bytecount[0] = BufDesc.getNumberOfBytesToTransfer();
		int Status = getConfigurationDescriptor(Handle, BufDesc.Buffer(), bytecount, Index);
		BufDesc.setBytesTransferred(bytecount[0]);
		return Status;
	}

	/**
	 * This function returns the current configuration value.
	 * <p>
	 * The configuration value returned by this function corresponds to the
	 * bConfiguration field of the active configuration descriptor.
	 * Note that the configuration value does not necessarily correspond
	 * to the index of the configuration descriptor.
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_GET_CONFIGURATION operation.
	 *
	 * @param ConfigurationValue If the function call is successful this variable returns the
	 * current configuration value.
	 * A value of 0 means the USB device is not configured.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#setConfiguration(USBIO_SET_CONFIGURATION)
	*/
	public int getConfiguration(byte[] ConfigurationValue) {
		if (ConfigurationValue == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		return getConfiguration(Handle, ConfigurationValue);
	}

	/**
	 * Get information on the interfaces and endpoints available in the current configuration.
	 * <p>
	 * The information returned is retrieved from the USBIO driver's internal
	 * data base.
	 * This function does not cause any action on the USB.
	 * <p>
	 * The device must have been opened before this function is called.
	 *
	 * @param ConfigurationInfo Reference to a caller-provided variable that receives the
 	 * configuration information.
 	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#setConfiguration(USBIO_SET_CONFIGURATION)
	 * @see de.thesycon.usbio.structs.USBIO_CONFIGURATION_INFO#USBIO_CONFIGURATION_INFO
	*/
	public int getConfigurationInfo(USBIO_CONFIGURATION_INFO ConfigurationInfo) {
		if (ConfigurationInfo == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		byte[] data = ConfigurationInfo.buildByteArray();
		int Status = getConfigurationInfo(Handle, data);
		ConfigurationInfo.parseByteArray(data);
		return Status;
	}

	/**
	 * Get the device descriptor from the device.
	 * <p>
	 * GetDeviceDescriptor calls {@link de.thesycon.usbio.UsbIo#getDescriptor(USBIO_DATA_BUFFER, int, byte, byte) getDescriptor} to retrieve the descriptor.
	 * Thus, for detailed information see also {@link de.thesycon.usbio.UsbIo#getDescriptor(USBIO_DATA_BUFFER, int, byte, byte) getDescriptor}.
	 * <p>
	 * The device must have been opened before this function is called.
	 *
	 * @param Desc Reference to a caller-provided variable that receives the requested descriptor.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#getDescriptor(USBIO_DATA_BUFFER, int, byte, byte)
	 * @see de.thesycon.usbio.UsbIo#getConfigurationDescriptor(USBIO_DATA_BUFFER, byte)
	 * @see de.thesycon.usbio.UsbIo#getStringDescriptor(USB_STRING_DESCRIPTOR, byte, int)
	 * @see de.thesycon.usbio.structs.USB_DEVICE_DESCRIPTOR#USB_DEVICE_DESCRIPTOR
	*/
	public int getDeviceDescriptor(USB_DEVICE_DESCRIPTOR Desc) {
		if (Desc == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		byte[] Buffer = new byte[Desc.getSize()];
		int Status = getDeviceDescriptor(Handle, Buffer);
		Desc.parseByteArray(Buffer);
		return Status;
	}

	/**
	 * Query device-related parameters from the USBIO device driver.
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_GET_DEVICE_PARAMETERS operation.
	 *
	 * @param DevParam Reference to a caller-provided variable that receives the
	 * current parameter settings.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#setDeviceParameters(USBIO_DEVICE_PARAMETERS)
	 * @see de.thesycon.usbio.structs.USBIO_DEVICE_PARAMETERS#USBIO_DEVICE_PARAMETERS
	*/
	public int getDeviceParameters(USBIO_DEVICE_PARAMETERS DevParam) {
		if (DevParam == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		byte[] Buffer = new byte[DevParam.getSize()];
		int Status = getDeviceParameters(Handle, Buffer);
		DevParam.parseByteArray(Buffer);
		return Status;
	}

	/**
	 * Set device-related parameters in the USBIO device driver.
	 * <p>
	 * Default device parameters are stored in the registry during USBIO driver installation.
	 * The default value can be changed in the INF file or in the registry.
	 * Device parameters set by means of this function are valid until the device
	 * is removed from the PC or the PC is booted.
	 * A modification during run-time does not change the default in the registry.
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_SET_DEVICE_PARAMETERS operation.
	 *
	 * @param DevParam Reference to a caller-provided variable that receives the
	 * current parameter settings.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#getDeviceDescriptor(USB_DEVICE_DESCRIPTOR)
	 * @see de.thesycon.usbio.structs.USBIO_DEVICE_PARAMETERS#USBIO_DEVICE_PARAMETERS
	*/
	public int setDeviceParameters(USBIO_DEVICE_PARAMETERS DevParam) {
		if (DevParam == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		byte[] Buffer = DevParam.buildByteArray();
		int Status = setDeviceParameters(Handle, Buffer);
		return Status;
	}

	/**
	 * Get information on the USBIO device driver.
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_GET_DRIVER_INFO operation.
	 *
	 * @param DriverInfo Reference to a caller-provided variable. The structure returns the API version, the driver version, and the build number.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#close()
	 * @see de.thesycon.usbio.structs.USBIO_DRIVER_INFO#USBIO_DRIVER_INFO
	*/
	public int getDriverInfo(USBIO_DRIVER_INFO DriverInfo) {
		if (DriverInfo == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		byte[] buffer = new byte[DriverInfo.getSize()];
		int Status =  getDriverInfo(Handle, buffer);
		DriverInfo.parseByteArray(buffer);
		return Status;
	}

	/**
	 * Set the device to the configured state.
	 * <p>
	 * The device has to be configured before any data transfer from or to
	 * its endpoints can take place.
	 * Only those endpoints that are included in the configuration
	 * will be activated and can be subsequently used for data transfers.
	 * <p>
	 * If the device provides more than one interface all interfaces
	 * must be configured in one call to this function.
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_SET_CONFIGURATION operation.
	 *
	 * @param Conf Reference to a caller-provided buffer.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#unconfigureDevice()
	 * @see de.thesycon.usbio.UsbIo#getConfiguration(byte[])
	 * @see de.thesycon.usbio.UsbIo#setInterface(USBIO_INTERFACE_SETTING)
	 * @see de.thesycon.usbio.structs.USBIO_SET_CONFIGURATION#USBIO_SET_CONFIGURATION
	*/
	public int setConfiguration(USBIO_SET_CONFIGURATION Conf) {
		if (Conf == null) {
			return USBIO_ERR_INVALID_PARAM;
		}
		return setConfiguration(Handle, Conf.buildByteArray());
	}

	/**
	 * Set the device to the unconfigured state.
	 * <p>
	 * The device must have been opened before this function is called.
	 * <p>
	 * This function is a wrapper for the IOCTL_USBIO_UNCONFIGURE_DEVICE operation.
	 *
	 * @return The function returns 0 if successful, an USBIO error code otherwise.
	 *
	 * @see de.thesycon.usbio.UsbIo#open(int, int, String)
	 * @see de.thesycon.usbio.UsbIo#setConfiguration(USBIO_SET_CONFIGURATION)
	 * @see de.thesycon.usbio.UsbIo#getConfiguration(byte[])
	*/
	public int unconfigureDevice() {
		return unconfigureDevice(Handle);
	}

	protected void finalize() throws Throwable {
		try {
			close();
		} finally {
			super.finalize();
		}
	}
}
