<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C: qf_port.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<h1>qf_port.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>QF port to QK for a "generic" C compiler.  
<a href="#_details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="qep__port_8h_source.html">qep_port.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="qk__port_8h_source.html">qk_port.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="qf_8h_source.html">qf.h</a>&quot;</code><br/>
<code>#include &quot;qf.h&quot;</code><br/>
</div>
<p><a href="qf__port_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389">QF_MAX_ACTIVE</a>&#160;&#160;&#160;63</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of active objects in the application.  <a href="#a776d2a032974db4bf9bcfde01ace1389"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#a1272d49c23ca5852a7a8e9603ba32d31">QF_EVENT_SIZ_SIZE</a>&#160;&#160;&#160;2</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The size (in bytes) of the event-size representation in the QF. Valid values: 1, 2, or 4; default 2.  <a href="#a1272d49c23ca5852a7a8e9603ba32d31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#a54463011114f6b076e0bd62e3fa27102">QF_EQUEUE_CTR_SIZE</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The size (in bytes) of the ring-buffer counters used in the native QF event queue implementation. Valid values: 1, 2, or 4; default 1.  <a href="#a54463011114f6b076e0bd62e3fa27102"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#ac41e4f294d103c68521f9ad1f8e4e3b4">QF_MPOOL_SIZ_SIZE</a>&#160;&#160;&#160;2</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The size (in bytes) of the block-size representation in the native QF event pool. Valid values: 1, 2, or 4; default <a class="el" href="qf__port_8h.html#a1272d49c23ca5852a7a8e9603ba32d31" title="The size (in bytes) of the event-size representation in the QF. Valid values: 1, 2, or 4; default 2.">QF_EVENT_SIZ_SIZE</a>.  <a href="#ac41e4f294d103c68521f9ad1f8e4e3b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#adc446a34e9e682fc5e821d203f73a6e0">QF_MPOOL_CTR_SIZE</a>&#160;&#160;&#160;2</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The size (in bytes) of the block-counter representation in the native QF event pool. Valid values: 1, 2, or 4; default 2.  <a href="#adc446a34e9e682fc5e821d203f73a6e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#a80d059a0d02a2573c76f4eb5df0228ae">QF_TIMEEVT_CTR_SIZE</a>&#160;&#160;&#160;2</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The size (in bytes) of the time event-counter representation in the <a class="el" href="struct_q_time_evt.html" title="Time Event structure.">QTimeEvt</a> struct. Valid values: 1, 2, or 4; default 2.  <a href="#a80d059a0d02a2573c76f4eb5df0228ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#a243406ad5c97d8a56625f0cd3bb41c67">QF_INT_KEY_TYPE</a>&#160;&#160;&#160;int</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the type of the interrupt lock key.  <a href="#a243406ad5c97d8a56625f0cd3bb41c67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#aecafaa15f9f2d55cc0557f8b4c951098">QF_INT_LOCK</a>(key_)&#160;&#160;&#160;((key_) = intLock())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the interrupt locking policy.  <a href="#aecafaa15f9f2d55cc0557f8b4c951098"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#a2f54624c77da2ce84f7666bd0695f186">QF_INT_UNLOCK</a>(key_)&#160;&#160;&#160;intUnlock(key_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the interrupt unlocking policy.  <a href="#a2f54624c77da2ce84f7666bd0695f186"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>QF port to QK for a "generic" C compiler. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of a QF port used for "linting" the QF. Ports of QF are located in the directory &lt;qpc_3&gt;/ports. </dd></dl>

<p>Definition in file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a54463011114f6b076e0bd62e3fa27102"></a><!-- doxytag: member="qf_port.h::QF_EQUEUE_CTR_SIZE" ref="a54463011114f6b076e0bd62e3fa27102" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_EQUEUE_CTR_SIZE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size (in bytes) of the ring-buffer counters used in the native QF event queue implementation. Valid values: 1, 2, or 4; default 1. </p>
<p>This macro can be defined in the QF ports to configure the ::QEQueueCtr type. If the macro is not defined, the default of 1 byte will be chosen in <a class="el" href="qequeue_8h.html" title="platform-independent event queue interface.">qequeue.h</a>. The valid <a class="el" href="qf__port_8h.html#a54463011114f6b076e0bd62e3fa27102" title="The size (in bytes) of the ring-buffer counters used in the native QF event queue implementation...">QF_EQUEUE_CTR_SIZE</a> values of 1, 2, or 4, correspond to ::QEQueueCtr of uint8_t, uint16_t, and uint32_t, respectively. The ::QEQueueCtr data type determines the dynamic range of numerical values of ring-buffer counters inside event queues, or, in other words, the maximum number of events that the native QF event queue can manage. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_q_e_queue.html" title="Native QF Event Queue.">QEQueue</a></dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Once you choose a certain value of <a class="el" href="qf__port_8h.html#a54463011114f6b076e0bd62e3fa27102" title="The size (in bytes) of the ring-buffer counters used in the native QF event queue implementation...">QF_EQUEUE_CTR_SIZE</a>, you must consistently use the same value in building all the QP component libraries and your own application code. The consistency is guaranteed if you define this macro only once in the <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C compiler.">qf_port.h</a> header file and henceforth include this header file in all builds. </dd></dl>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00098">98</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1272d49c23ca5852a7a8e9603ba32d31"></a><!-- doxytag: member="qf_port.h::QF_EVENT_SIZ_SIZE" ref="a1272d49c23ca5852a7a8e9603ba32d31" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_EVENT_SIZ_SIZE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size (in bytes) of the event-size representation in the QF. Valid values: 1, 2, or 4; default 2. </p>
<p>This macro can be defined in the QF ports to configure the ::QEventSize type. If the macro is not defined, the default of 2 byte will be chosen in <a class="el" href="qf_8h.html" title="QF/C platform-independent public interface.">qf.h</a>. The valid <a class="el" href="qf__port_8h.html#a1272d49c23ca5852a7a8e9603ba32d31" title="The size (in bytes) of the event-size representation in the QF. Valid values: 1, 2, or 4; default 2.">QF_EVENT_SIZ_SIZE</a> values of 1, 2, or 4, correspond to ::QEventSize of uint8_t, uint16_t, and uint32_t, respectively. The ::QEventSize data type determines the dynamic range of event-sizes in your application. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a63817909aa88407fd7d6c1ff3706a249" title="Event pool initialization for dynamic allocation of events.">QF_poolInit()</a>, <a class="el" href="qf_8h.html#a2128fe3499dc6ed8100f5deed5a779a1" title="Internal QF implementation of the dynamic event allocator.">QF_new_()</a></dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Once you choose a certain value of <a class="el" href="qf__port_8h.html#a1272d49c23ca5852a7a8e9603ba32d31" title="The size (in bytes) of the event-size representation in the QF. Valid values: 1, 2, or 4; default 2.">QF_EVENT_SIZ_SIZE</a>, you must consistently use the same value in building all the QP component libraries and your own application code. The consistency is guaranteed if you define this macro only once in the <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C compiler.">qf_port.h</a> header file and henceforth include this header file in all builds. </dd></dl>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00078">78</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

</div>
</div>
<a class="anchor" id="a243406ad5c97d8a56625f0cd3bb41c67"></a><!-- doxytag: member="qf_port.h::QF_INT_KEY_TYPE" ref="a243406ad5c97d8a56625f0cd3bb41c67" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_INT_KEY_TYPE&#160;&#160;&#160;int</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the type of the interrupt lock key. </p>
<p>Defining this macro configures the "saving and restoring interrupt status" policy of locking and unlocking interrupts. Coversely, if this macro is not defined, the simple "unconditional interrupt locking and unlocking" is used. </p>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00168">168</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

</div>
</div>
<a class="anchor" id="aecafaa15f9f2d55cc0557f8b4c951098"></a><!-- doxytag: member="qf_port.h::QF_INT_LOCK" ref="aecafaa15f9f2d55cc0557f8b4c951098" args="(key_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_INT_LOCK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_</td><td>)</td>
          <td>&#160;&#160;&#160;((key_) = intLock())</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the interrupt locking policy. </p>
<p>This macro establishes a critical section (typically by locking interrupts). When the "saving and restoring interrupt status" policy is used, the macro sets the "interrupt key" to the interrupt status just before locking interrupts. When the policy of "unconditional interrupt unlocking" is used, the macro does not use the "interrupt key" parameter.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the <a class="el" href="qf__port_8h.html#aecafaa15f9f2d55cc0557f8b4c951098" title="Define the interrupt locking policy.">QF_INT_LOCK</a> macro should always be used in pair with the macro <a class="el" href="qf__port_8h.html#a2f54624c77da2ce84f7666bd0695f186" title="Define the interrupt unlocking policy.">QF_INT_UNLOCK</a>. </dd></dl>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00181">181</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2f54624c77da2ce84f7666bd0695f186"></a><!-- doxytag: member="qf_port.h::QF_INT_UNLOCK" ref="a2f54624c77da2ce84f7666bd0695f186" args="(key_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_INT_UNLOCK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_</td><td>)</td>
          <td>&#160;&#160;&#160;intUnlock(key_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the interrupt unlocking policy. </p>
<p>This macro leaves a critical section (typically by unlocking interrupts). When the "saving and restoring interrupt status" policy is used, the macro restores the interrupt status from the "interrupt key" parameter. When the policy of "unconditional interrupt unlocking" is used, the macro unconditionally unlocks interrupts ignoring the "interrupt key" parameter.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the <a class="el" href="qf__port_8h.html#aecafaa15f9f2d55cc0557f8b4c951098" title="Define the interrupt locking policy.">QF_INT_LOCK</a> macro should always be used in pair with the macro <a class="el" href="qf__port_8h.html#a2f54624c77da2ce84f7666bd0695f186" title="Define the interrupt unlocking policy.">QF_INT_UNLOCK</a>. </dd></dl>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00194">194</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

</div>
</div>
<a class="anchor" id="a776d2a032974db4bf9bcfde01ace1389"></a><!-- doxytag: member="qf_port.h::QF_MAX_ACTIVE" ref="a776d2a032974db4bf9bcfde01ace1389" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_MAX_ACTIVE&#160;&#160;&#160;63</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum number of active objects in the application. </p>
<p>This macro should be defined in the QF ports and should be in range of 1..63, inclusive. The value of this macro determines the maximum priority level of an active object in the system. Not all priority levels must be used, but the maximum priority cannot exceed <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>.</p>
<p>If the macro is not defined, the default value is 63, which is the maximum. Defining the value below the maximum saves some memory, mostly for the subscriber-lists. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_q_subscr_list.html" title="Subscriber-List structure.">QSubscrList</a>.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Once you choose a certain value of <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>, you must consistently use the same value in building all the QP component libraries and your own application code. The consistency is guaranteed if you define this macro only once in the <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C compiler.">qf_port.h</a> header file and henceforth include this header file in all builds. </dd></dl>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00059">59</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

<p>Referenced by <a class="el" href="qk_8c_source.html#l00091">QActive_start()</a>, <a class="el" href="qa__sub_8c_source.html#l00040">QActive_subscribe()</a>, <a class="el" href="qa__usub_8c_source.html#l00040">QActive_unsubscribe()</a>, <a class="el" href="qa__usuba_8c_source.html#l00040">QActive_unsubscribeAll()</a>, and <a class="el" href="qa__get___8c_source.html#l00085">QF_getQueueMargin()</a>.</p>

</div>
</div>
<a class="anchor" id="adc446a34e9e682fc5e821d203f73a6e0"></a><!-- doxytag: member="qf_port.h::QF_MPOOL_CTR_SIZE" ref="adc446a34e9e682fc5e821d203f73a6e0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_MPOOL_CTR_SIZE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size (in bytes) of the block-counter representation in the native QF event pool. Valid values: 1, 2, or 4; default 2. </p>
<p>This macro can be defined in the QF ports to configure the ::QMPoolCtr type. If the macro is not defined, the default of 2 bytes will be chosen in <a class="el" href="qmpool_8h.html" title="platform-independent memory pool interface.">qmpool.h</a>. The valid <a class="el" href="qf__port_8h.html#adc446a34e9e682fc5e821d203f73a6e0" title="The size (in bytes) of the block-counter representation in the native QF event pool. Valid values: 1, 2, or 4; default 2.">QF_MPOOL_CTR_SIZE</a> values of 1, 2, or 4, correspond to ::QMPoolSize of uint8_t, uint16_t, and uint32_t, respectively. The ::QMPoolCtr data type determines the dynamic range of block-counters that the native <a class="el" href="struct_q_m_pool.html" title="Native QF Memory Pool.">QMPool</a> can handle, or, in other words, the maximum number of blocks that the native QF event pool can manage. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_q_m_pool.html" title="Native QF Memory Pool.">QMPool</a></dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Once you choose a certain value of <a class="el" href="qf__port_8h.html#adc446a34e9e682fc5e821d203f73a6e0" title="The size (in bytes) of the block-counter representation in the native QF event pool. Valid values: 1, 2, or 4; default 2.">QF_MPOOL_CTR_SIZE</a>, you must consistently use the same value in building all the QP component libraries and your own application code. The consistency is guaranteed if you define this macro only once in the <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C compiler.">qf_port.h</a> header file and henceforth include this header file in all builds. </dd></dl>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00140">140</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac41e4f294d103c68521f9ad1f8e4e3b4"></a><!-- doxytag: member="qf_port.h::QF_MPOOL_SIZ_SIZE" ref="ac41e4f294d103c68521f9ad1f8e4e3b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_MPOOL_SIZ_SIZE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size (in bytes) of the block-size representation in the native QF event pool. Valid values: 1, 2, or 4; default <a class="el" href="qf__port_8h.html#a1272d49c23ca5852a7a8e9603ba32d31" title="The size (in bytes) of the event-size representation in the QF. Valid values: 1, 2, or 4; default 2.">QF_EVENT_SIZ_SIZE</a>. </p>
<p>This macro can be defined in the QF ports to configure the ::QMPoolSize type. If the macro is not defined, the default of <a class="el" href="qf__port_8h.html#a1272d49c23ca5852a7a8e9603ba32d31" title="The size (in bytes) of the event-size representation in the QF. Valid values: 1, 2, or 4; default 2.">QF_EVENT_SIZ_SIZE</a> will be chosen in <a class="el" href="qmpool_8h.html" title="platform-independent memory pool interface.">qmpool.h</a>, because the memory pool is primarily used for implementing event pools.</p>
<p>The valid <a class="el" href="qf__port_8h.html#ac41e4f294d103c68521f9ad1f8e4e3b4" title="The size (in bytes) of the block-size representation in the native QF event pool. Valid values: 1...">QF_MPOOL_SIZ_SIZE</a> values of 1, 2, or 4, correspond to ::QMPoolSize of uint8_t, uint16_t, and uint32_t, respectively. The ::QMPoolSize data type determines the dynamic range of block-sizes that the native <a class="el" href="struct_q_m_pool.html" title="Native QF Memory Pool.">QMPool</a> can hanle. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf__port_8h.html#a1272d49c23ca5852a7a8e9603ba32d31" title="The size (in bytes) of the event-size representation in the QF. Valid values: 1, 2, or 4; default 2.">QF_EVENT_SIZ_SIZE</a>, <a class="el" href="struct_q_m_pool.html" title="Native QF Memory Pool.">QMPool</a></dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Once you choose a certain value of <a class="el" href="qf__port_8h.html#ac41e4f294d103c68521f9ad1f8e4e3b4" title="The size (in bytes) of the block-size representation in the native QF event pool. Valid values: 1...">QF_MPOOL_SIZ_SIZE</a>, you must consistently use the same value in building all the QP component libraries and your own application code. The consistency is guaranteed if you define this macro only once in the <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C compiler.">qf_port.h</a> header file and henceforth include this header file in all builds. </dd></dl>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00120">120</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

</div>
</div>
<a class="anchor" id="a80d059a0d02a2573c76f4eb5df0228ae"></a><!-- doxytag: member="qf_port.h::QF_TIMEEVT_CTR_SIZE" ref="a80d059a0d02a2573c76f4eb5df0228ae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_TIMEEVT_CTR_SIZE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size (in bytes) of the time event-counter representation in the <a class="el" href="struct_q_time_evt.html" title="Time Event structure.">QTimeEvt</a> struct. Valid values: 1, 2, or 4; default 2. </p>
<p>This macro can be defined in the QF ports to configure the internal tick counters of Time Events. If the macro is not defined, the default of 2 bytes will be chosen in <a class="el" href="qf_8h.html" title="QF/C platform-independent public interface.">qf.h</a>. The valid <a class="el" href="qf__port_8h.html#a80d059a0d02a2573c76f4eb5df0228ae" title="The size (in bytes) of the time event-counter representation in the QTimeEvt struct. Valid values: 1, 2, or 4; default 2.">QF_TIMEEVT_CTR_SIZE</a> values of 1, 2, or 4, correspond to tick counters of uint8_t, uint16_t, and uint32_t, respectively. The tick counter representation determines the dynamic range of time delays that a Time Event can handle. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_q_time_evt.html" title="Time Event structure.">QTimeEvt</a></dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Once you choose a certain value of <a class="el" href="qf__port_8h.html#a80d059a0d02a2573c76f4eb5df0228ae" title="The size (in bytes) of the time event-counter representation in the QTimeEvt struct. Valid values: 1, 2, or 4; default 2.">QF_TIMEEVT_CTR_SIZE</a>, you must consistently use the same value in building all the QP component libraries and your own application code. The consistency is guaranteed if you define this macro only once in the <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C compiler.">qf_port.h</a> header file and henceforth include this header file in all builds. </dd></dl>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00159">159</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Jan 7 2011 21:36:56 for QP/C by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
