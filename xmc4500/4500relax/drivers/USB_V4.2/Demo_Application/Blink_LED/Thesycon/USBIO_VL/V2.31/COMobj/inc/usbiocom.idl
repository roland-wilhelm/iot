// USBIOCOM.idl : IDL source for USBIOCOM.dll
//

// This file will be processed by the MIDL tool to
// produce the type library (USBIOCOM.tlb) and marshalling code.

import "oaidl.idl";
import "ocidl.idl";

//*************** IUSBIOInterface3 **********************
[
  object,
  uuid(775938FE-790A-476e-BA6D-20BE61EFE5BC),
  dual,
  helpstring("IUSBIOInterface3 Interface"),
  pointer_default(unique)
]
interface IUSBIOInterface3 : IDispatch
{
/*doc ComIf
%% \begin{class}{}{ Interface}{IUSBIOInterface}{
%%  The \temph{IUSBIOInterface} interface enables applications to control an instance of the 
%%  USBIO COM object.
%%  }
*/

    // enumeration, open, close
    [id(1), helpstring("Call this function to enumerate all devices with the USBIO driver interface. The function returns the number of devices present, -1 in case of an error.")] 
    HRESULT EnumerateDevices(
              [in] BSTR GUIDDriverInterface,
              [out] int *NumberOfDevices
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{EnumerateDevices}{}{
  This function enumerates all USB devices which are currently connected to the system and 
  controlled by the USBIO device driver. 
  }
  \param{[in] BSTR}{GUIDDriverInterface}{}{
  A string representation of a GUID that identifies the driver interface exported by the USBIO driver.
  This can be the default USBIO GUID \{325ddf96-938c-11d3-9e34-0080c82727f4\} that is defined
  in \tital{usbio_i.h}.
  However, it is strongly recommended that a private GUID is used which has been generated by a tool
  like \tital{guidgen.exe}.
  This is important in order to differentiate between various customizations of the USBIO product.

  For the USBIO device driver the private GUID has to be defined in the setup information file \tital{usbio.inf}.
  See the USBIO Reference Manual and the \tital{usbio.inf} file for details.
  }
  \param{[out] int*}{NumberOfDevices}{}{
  A variable that receives the number of USB devices which are currently connected to the USBIO device driver.
  The returned value can be zero which indicates that no devices are available.
  A return value of -1 indicates that the format of the specified GUID is invalid.
  }
  \comments{
  The function builds an internal list of currently available USB devices. 
  Each device from this list can be opened by means of the function \hl{OpenDevice}.
  A device is identified by a zero-based index.
  Thus, valid device numbers are in the range of zero to NumberOfDevices-1.
  The index of a device is temporary and will be re-assigned on the next call to this function.

  Note that the internal device list is global. 
  All instances of the USBIO COM object do access the same list.
  When \hl{OpenDevice} is called on an instance the global device list
  that was built by a call to EnumerateDevices will be consulted to locate the device
  identified by the device index passed to the function.
  Because the list is global it does not make any difference which USBIO COM object instance 
  is used to call EnumerateDevices.
  Besides, it is sufficient to call EnumerateDevices one one instance.
  
  After a USB device is connected to the system this function has to be called before the device
  can be opened and used for I/O operations.
  Consequently, EnumerateDevices has to be called before \hl{OpenDevice} is called.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{CloseDevice} \\
  \sa{DevicePathName}
  }
\end{function}
\pagebreak
*/

    [id(2), helpstring("Open a device instance. EnumerateDevices has to be called first!")] 
    HRESULT OpenDevice(
              [in] int DeviceNumber,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{OpenDevice}{}{
  This function opens a USB device which is currently connected to the USBIO device driver and has been
  enumerated by \hl{EnumerateDevices}.
  }
  \param{[in] int}{DeviceNumber}{}{
  Identifies the device to be opened by its zero-based index in the internal device list
  built by \hl{EnumerateDevices}.
  Valid device numbers range from zero to NumberOfDevices-1.
  NumberOfDevices is returned by \hl{EnumerateDevices}.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  To identify the device OpenDevice uses the internal device list which has been built by a call to 
  \hl{EnumerateDevices}.
  The index of a device is temporary and will be re-assigned on the next call to \hl{EnumerateDevices}.
  When more than one USB device is present on the bus then there is no guarantee that an one-to-one
  relation of device numbers and physical devices will be maintained over several 
  calls to \hl{EnumerateDevices}.
  In order to unambiguously identify a physical device an application should query USB descriptors,
  e.g. the USB device descriptor, and the serial number.

  Note that the internal device list built by \hl{EnumerateDevices} is global.
  Regardless of the object instance on that OpenDevice is called the same global list
  will be used to locate the device identified by \temph{DeviceNumber}.
  For more information see also the description of \hl{EnumerateDevices}.

  It is recommended that device enumeration is done in a two step process:\\
  (1) Call EnumerateDevices on one object instance.\\
  (2) Call OpenDevice on each object instance to be associated with a device.
  
  OpenDevice fails if the major USBIO driver version is different from the version of the USBIO COM object.
  Make sure that the USBIO device driver and the USBIO COM interface versions do match.

  The operation fails if the device is acquired by a different process.
  }
  \seealso{
  \sa{CloseDevice} \\
  \sa{EnumerateDevices} \\
  \sa{DevicePathName} \\
  \sa{AcquireDevice}
  }
\end{function}
\pagebreak
*/

    [id(3), helpstring("Close the device instance.")] 
    HRESULT CloseDevice();
/*doc 
\begin{function}{}{ Method }{HRESULT}{CloseDevice}{}{
  This function closes a USB device previously opened by a call to \hl{OpenDevice}. 
  }
  \comments{
  All read and write operations associated with the instance will be stopped by this call.
  
  If the last USBIO COM object instance for a device is closed either
  the device is set to the unconfigured state or a USB reset is forced,
  depending on the configuration of the USBIO device driver.
  The behavior can be configured by means of the function \hl{DeviceOptions}.
  The default behavior is defined by means of registry parameters.
  For details refer to the USBIO Reference Manual.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{EnumerateDevices} \\
  \sa{DeviceOptions}
  }
\end{function}
\pagebreak
*/


    [propget, id(4), helpstring("Returns the path name of the driver interface.")] 
    HRESULT DevicePathName([out,retval] BSTR *DevicePath);
/*doc
\begin{function}{}{ Property }{HRESULT}{DevicePathName}{}{
  This read-only property returns the full device path string of the device instance.
  }
  \param{[out,retval] BSTR*}{DevicePathName}{}{
  A variable that receives the device path string.
  }
  \comments{
  The device path string returned by this function can be passed to the Win32 API function
  \tital{CreateFile()} to open the USB device which is controlled by the USBIO driver.
  Refer to the USBIO Reference Manual and the Win32 documentation for further details.

  This property can only be read after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice}
  }
\end{function}
\pagebreak
*/


    // driver properties
    [id(5), helpstring("Returns version information about the USBIO driver.")] 
    HRESULT GetDriverInfo(
              [out] int *APIVersion,
              [out] int *DriverVersion,
              [out] int *DriverBuildNumber,
              [out] int *Flags,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{GetDriverInfo}{}{
  This function returns version information on the USBIO device driver.
  }
  \param{[out] int*}{APIVersion}{}{
  A variable that receives the version number of the native USBIO device driver API.
  The format is as follows: bits 15..8 = major version, bits 7..0 = minor version.
  The numbers are encoded in BCD format.
  }
  \param{[out] int*}{DriverVersion}{}{
  A variable that receives the version number of the USBIO device driver executable.
  The format is as follows: bits 15..8 = major version, bits 7..0 = minor version.
  }
  \param{[out] int*}{DriverBuildNumber}{}{
  A variable that receives the build number of the USBIO device driver executable.
  }
  \param{[out] int*}{Flags}{}{
  A variable that receives additional information encoded as bit flags.
  The value is zero or any combination (bit-wise or) of the following values.
  \begin{description1}

  \item[USBIOCOM_INFOFLAG_CHECKED_BUILD]
  If this flag is set the driver that is currently running is a checked (debug) build.

  \vspace{2mm}
  \item[USBIOCOM_INFOFLAG_DEMO_VERSION]
  If this flag is set the driver that is currently running is a DEMO version that has some restrictions.
  Refer to \tital{ReadMe.txt} for a description of the restrictions.

  \vspace{2mm}
  \item[USBIOCOM_INFOFLAG_LIGHT_VERSION]
  If this flag is set the driver that is currently running is a LIGHT version that has some restrictions.
  Refer to \tital{ReadMe.txt} for a description of the restrictions.

  \end{description1}
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  This function can only be used after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{IsCheckedBuild} \\
  \sa{IsDemoVersion} \\
  \sa{IsLightVersion} \\
  \sa{USBIOCOM_INFO_FLAGS}
  }
\end{function}
\pagebreak
*/

    [propget, id(6), helpstring("Returns TRUE if a debug build of the USBIO driver is running, FALSE otherwise.")] 
    HRESULT IsCheckedBuild([out,retval] BOOL *Checked);
/*doc
\begin{function}{}{ Property }{HRESULT}{IsCheckedBuild}{}{
  This read-only property returns TRUE if the checked (debug) build of the USBIO device driver
  is currently running, FALSE otherwise.
  }
  \param{[out,retval] BOOL*}{Checked}{}{
  A variable that will be set to TRUE or FALSE.
  }
  \comments{
  The USBIO driver debug build is useful for investigation of problems and advanced tracing.
  Refer to the USBIO Reference Manual for more information.

  This property can only be read after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{IsDemoVersion} \\
  \sa{IsLightVersion} \\
  \sa{GetDriverInfo}
  }
\end{function}
\pagebreak
*/

    [propget, id(7), helpstring("Returns TRUE if a demo version of the USBIO driver is running, FALSE otherwise.")] 
    HRESULT IsDemoVersion([out,retval] BOOL *DemoVersion);
/*doc
\begin{function}{}{ Property }{HRESULT}{IsDemoVersion}{}{
  This read-only property returns TRUE if the the demo version of the USBIO device driver
  is currently running, FALSE otherwise.
  }
  \param{[out,retval] BOOL*}{DemoVersion}{}{
  A variable that will be set to TRUE or FALSE.
  }
  \comments{
  The USBIO demo version enforces some restrictions.
  Refer to \tital{ReadMe.txt} for detailed information.

  This property can only be read after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{IsCheckedBuild} \\
  \sa{IsLightVersion} \\
  \sa{GetDriverInfo}
  }
\end{function}
\pagebreak
*/

    [propget, id(8), helpstring("Returns TRUE if a light version of the USBIO driver is running, FALSE otherwise.")] 
    HRESULT IsLightVersion([out,retval] BOOL *LightVersion);
/*doc
\begin{function}{}{ Property }{HRESULT}{IsLightVersion}{}{
  This read-only property returns TRUE if the the light version of the USBIO device driver
  is currently running, FALSE otherwise.
  }
  \param{[out,retval] BOOL*}{LightVersion}{}{
  A variable that will be set to TRUE or FALSE.
  }
  \comments{
  The USBIO light version enforces some restrictions.
  Refer to \tital{ReadMe.txt} for detailed information.

  This property can only be read after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{IsCheckedBuild} \\
  \sa{IsDemoVersion} \\
  \sa{GetDriverInfo}
  }
\end{function}
\pagebreak
*/


    // device-related options
    [propget, id(9), helpstring("Get current device options.")] 
    HRESULT DeviceOptions(
              [out,retval] int *Options
              );
/*doc
\begin{function}{}{ Property }{HRESULT}{DeviceOptions}{}{
  Reading this property retrieves the current options set for the device instance.
  }
  \param{[out,retval] int*}{Options}{}{
  A variable that receives the current device options, encoded as bit flags.
  See below for a detailed description.
  }
\end{function}
*/
    [propput, id(9), helpstring("Set device options.")] 
    HRESULT DeviceOptions(
              [in] int Options
              );
/*doc
\def\tfdoclabelextn{:1} % set label extension to ':1'
\begin{function}{}{ Property }{HRESULT}{DeviceOptions}{}{
  Writing this property sets options for the device instance.
  }
  \param{[in] int}{Options}{}{
  Specifies device options to be set, encoded as bit flags.
  The value is zero or any combination (bit-wise or) of the following values.
  \begin{description1}

  \item[USBIOCOM_RESET_DEVICE_ON_CLOSE]
    If this option is set a USB device reset is sent to the device after the last USBIO COM object instance
    has closed the device by a call to \hl{CloseDevice}.

  \vspace{2mm}
  \item[USBIOCOM_UNCONFIGURE_ON_CLOSE]
    If this option is set the USB device will be unconfigured after the last USBIO COM object instance
    has closed the device by a call to \hl{CloseDevice}.

  \vspace{2mm}
  \item[USBIOCOM_ENABLE_REMOTE_WAKEUP]
    If this option is set the remote wake-up feature is enabled for the device.
    At least one USBIO COM object instance must be open for the device to allow
    the remote wake-up event to occur.

  \end{description1}
  }
  \comments{
  Default device options are stored in the registry during USBIO driver installation.
  The default value can be changed in the INF file or in the registry.
  Device options set by means of this property are valid until the device is removed from the PC or the PC is booted.
  A modification during run-time does not change the default in the registry.
  
  This property can only be read or written after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{USBIOCOM_DEVICE_OPTION_FLAGS} \\
  \sa{DeviceRequestTimeout}
  }
\end{function}
\def\tfdoclabelextn{} % set label extension to empty
\pagebreak
*/

    [propget, id(10), helpstring("Get current request time-out interval setting.")] 
    HRESULT DeviceRequestTimeout(
              [out, retval] int *pVal
              );
/*doc
\begin{function}{}{ Property }{HRESULT}{DeviceRequestTimeout}{}{
  Reading this property retrieves the current time-out interval for control requests set for the device instance.
  }
  \param{[out,retval] int*}{pVal}{}{
  A variable that receives the current time-out interval.
  See below for a detailed description.
  }
\end{function}
*/
    [propput, id(10), helpstring("Set request time-out interval, 0 for infinite.")] 
    HRESULT DeviceRequestTimeout(
              [in] int newVal
              );
/*doc
\def\tfdoclabelextn{:1} % set label extension to ':1'
\begin{function}{}{ Property }{HRESULT}{DeviceRequestTimeout}{}{
  Writing this property sets the time-out interval for control requests for the device instance.
  }
  \param{[in] int}{newVal}{}{
  Specifies the time-out interval, in ms.
  A value of zero specifies an infinite interval.
  This forces the driver to wait until a request is completed.
  }
  \comments{
  This property allows to retrieve or set the time-out interval that applies to all control requests.
  The time-out interval is in effect for USB control requests only, particularly this includes EP0 requests.
  The time-out will not affect data transmission from or to endpoints.

  Note that setting an infinite time-out interval may be useful to halt the device's firmware in a debugger.

  A default time-out interval is stored in the registry during USBIO driver installation.
  The default value can be changed in the INF file or in the registry.
  A time-out interval set by means of this property is valid until the device is removed from the PC or the PC is booted.
  A modification during run-time does not change the default in the registry.
  
  This property can only be read or written after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{DeviceOptions}
  }
\end{function}
\def\tfdoclabelextn{} % set label extension to empty
\pagebreak
*/


    // descriptors
    [id(12), helpstring("Get a USB descriptor from the device.")] 
    HRESULT GetDescriptor(
              [in,out] SAFEARRAY(unsigned char) *Descriptor, 
              [in,out] int *DescSize, 
              [in] int Recipient, 
              [in] int DescriptorType, 
              [in] int DescriptorIndex,
              [in] int LanguageId,
              [out] int *Status
              );
/*doc 
\begin{function}{}{ Method }{HRESULT}{GetDescriptor}{}{
  This function retrieves a descriptor from the USB device.
  }
  \param{[in,out] SAFEARRAY(unsigned char)*}{Descriptor}{}{
  An array type variable that receives the requested descriptor.
  The caller has to provide this variable.
  The array will not be resized by the COM object.
  Consequently, the array has to provide enough storage for the descriptor.
  }
  \param{[in,out] int*}{DescSize}{}{
  A variable that specifies the number of bytes to request.
  This can be less than the size of the descriptor.
  Only the specified part of the descriptor will be returned in this case.
  The number of bytes requested must not exceed 4096 and must be less than or equal
  to the number of bytes provided in \temph{Descriptor}.
  
  After the GetDescriptor function succeeds the \temph{DescSize} variable will be set to the
  number of bytes returned in the \temph{Descriptor} array.
  }
  \param{[in] int}{Recipient}{}{
  Specifies the recipient of the GET_DESCRIPTOR request.
  The values are defined by the enumeration type \hl{USBIOCOM_REQUEST_RECIPIENT}.
  }
  \param{[in] int}{DescriptorType}{}{
  Specifies the type of descriptor to get from the device.
  The values are defined by the enumeration type \hl{USBIOCOM_DESCRIPTOR_TYPE}.
  These numerical values are defined by the Universal Serial Bus Specification, Chapter~9 
  and additional device class specifications.
  }
  \param{[in] int}{DescriptorIndex}{}{
  Specifies the zero-based index of the descriptor to get from the device.
  The meaning depends on the descriptor type. 
  For example, in case of the device descriptor \temph{DescriptorIndex} is not used and
  should be set to zero.
  }
  \param{[in] int}{LanguageId}{}{
  Specifies the language ID of the string descriptor to get.
  Set to zero for other descriptor types.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  This function allows to request any descriptor from the USB device.
  To query common descriptor types in a more comfortable way the specialized functions 
  \hl{GetDeviceDescriptor}, \hl{GetConfigurationDescriptor}, and \hl{GetStringDescriptor}
  are provided.
  
  This function can only be used after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{GetDeviceDescriptor} \\
  \sa{GetConfigurationDescriptor} \\
  \sa{GetStringDescriptor} \\
  \sa{SetDescriptor} \\
  \sa{USBIOCOM_REQUEST_RECIPIENT} \\
  \sa{USBIOCOM_DESCRIPTOR_TYPE}
  }
\end{function}
\pagebreak
*/

    [id(13), helpstring("Get the USB device descriptor from the device.")] 
    HRESULT GetDeviceDescriptor(
              [in,out] SAFEARRAY(unsigned char) *DeviceDescriptor,
              [in,out] int *DescSize,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{GetDeviceDescriptor}{}{
  This function retrieves the device descriptor from the USB device.
  }
  \param{[in,out] SAFEARRAY(unsigned char)*}{DeviceDescriptor}{}{
  An array type variable that receives the requested descriptor.
  The caller has to provide this variable.
  The array will not be resized by the COM object.
  Consequently, the array has to provide enough storage for the descriptor.
  }
  \param{[in,out] int*}{DescSize}{}{
  A variable that specifies the number of bytes to request.
  This can be less than the size of the descriptor.
  Only the specified part of the descriptor will be returned in this case.
  The number of bytes requested must not exceed 4096 and must be less than or equal
  to the number of bytes provided in \temph{DeviceDescriptor}.
  
  After the GetDeviceDescriptor function succeeds the \temph{DescSize} variable will be set to the
  number of bytes returned in the \temph{DeviceDescriptor} array.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  According to the USB specification the size of the device descriptor is 18~bytes.
  
  This function can only be used after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{GetConfigurationDescriptor} \\
  \sa{GetStringDescriptor} \\
  \sa{GetDescriptor}
  }
\end{function}
\pagebreak
*/

    [id(14), helpstring("Get a configuration descriptor from the device.")] 
    HRESULT GetConfigurationDescriptor(
              [in,out] SAFEARRAY(unsigned char) *ConfigDescriptor,
              [in,out] int *DescSize,
              [in] unsigned char Index,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{GetConfigurationDescriptor}{}{
  This function retrieves a configuration descriptor from the USB device.
  }
  \param{[in,out] SAFEARRAY(unsigned char)*}{ConfigDescriptor}{}{
  An array type variable that receives the requested descriptor.
  The caller has to provide this variable.
  The array will not be resized by the COM object.
  Consequently, the array has to provide enough storage for the descriptor.
  }
  \param{[in,out] int*}{DescSize}{}{
  A variable that specifies the number of bytes to request.
  This can be less than the size of the descriptor.
  Only the specified part of the descriptor will be returned in this case.
  The number of bytes requested must not exceed 4096 and must be less than or equal
  to the number of bytes provided in \temph{ConfigDescriptor}.
  
  After the GetConfigurationDescriptor function succeeds the \temph{DescSize} variable will be set to the
  number of bytes returned in the \temph{ConfigDescriptor} array.
  }
  \param{[in] unsigned char}{Index}{}{
  Specifies the zero-based index of the configuration descriptor to be retrieved.
  The valid range depends on the number of configurations the device supports.
  If the device supports one configuration only \temph{Index} has to be set to zero.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  According to the USB specification the total size of the configuration descriptor is indicated 
  by the bytes 3 and 4 (\tital{wTotalLength} field) of the descriptor.
  Refer to the specification for detailed information.
  
  This function can only be used after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{GetDeviceDescriptor} \\
  \sa{GetStringDescriptor} \\
  \sa{GetDescriptor}
  }
\end{function}
\pagebreak
*/

    [id(15), helpstring("Get a string descriptor from the device.")] 
    HRESULT GetStringDescriptor(
              [in,out] SAFEARRAY(unsigned char) *StringDescriptor, 
              [in,out] int *DescSize,
              [in] unsigned char Index, 
              [in] int LanguageId, 
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{GetStringDescriptor}{}{
  This function retrieves a string descriptor from the USB device.
  }
  \param{[in,out] SAFEARRAY(unsigned char)*}{StringDescriptor}{}{
  An array type variable that receives the requested descriptor.
  The caller has to provide this variable.
  The array will not be resized by the COM object.
  Consequently, the array has to provide enough storage for the descriptor.
  }
  \param{[in,out] int*}{DescSize}{}{
  A variable that specifies the number of bytes to request.
  This can be less than the size of the descriptor.
  Only the specified part of the descriptor will be returned in this case.
  The number of bytes requested must not exceed 4096 and must be less than or equal
  to the number of bytes provided in \temph{StringDescriptor}.
  
  After the GetStringDescriptor function succeeds the \temph{DescSize} variable will be set to the
  number of bytes returned in the \temph{StringDescriptor} array.
  }
  \param{[in] unsigned char}{Index}{}{
  Specifies the zero-based index of the string descriptor to be retrieved.
  The index values are defined by the device.
  If \temph{Index} is set to zero the device returns a list of language ID's it supports. 
  }
  \param{[in] int}{LanguageId}{}{
  Specifies the language ID of the string descriptor to be retrieved.
  This should be a language ID which is supported by the device.
  A list of supported language ID's is returned if \temph{Index} is set to zero.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  A string descriptor contains a UNICODE string.
  The first two bytes describe the type and the length of the descriptor.
  Refer to the USB specification for detailed information.
  
  According to the USB specification the maximum size of a string descriptor is 256~bytes.
  
  This function can only be used after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{GetDeviceDescriptor} \\
  \sa{GetConfigurationDescriptor} \\
  \sa{GetDescriptor}
  }
\end{function}
\pagebreak
*/

    [id(16), helpstring("Send a SET_DESCRIPTOR request to the USB device.")] 
    HRESULT SetDescriptor(
              [in,out] SAFEARRAY(unsigned char) *Descriptor,
              [in] int Recipient,
              [in] int DescriptorType,
              [in] int DescriptorIndex, 
              [in] int LanguageId,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{SetDescriptor}{}{
  This function can be used to set a descriptor in the USB device.
  }
  \param{[in,out] SAFEARRAY(unsigned char)*}{Descriptor}{}{
  An array type variable that provides the descriptor to set.
  }
  \param{[in] int}{Recipient}{}{
  Specifies the recipient of the SET_DESCRIPTOR request.
  The values are defined by the enumeration type \hl{USBIOCOM_REQUEST_RECIPIENT}.
  }
  \param{[in] int}{DescriptorType}{}{
  Specifies the type of the descriptor to set.
  The values are defined by the enumeration type \hl{USBIOCOM_DESCRIPTOR_TYPE}.
  These numerical values are defined by the Universal Serial Bus Specification, Chapter~9 
  and additional device class specifications.
  }
  \param{[in] int}{DescriptorIndex}{}{
  Specifies the zero-based index of the descriptor to set.
  The meaning depends on the descriptor type.
  }
  \param{[in] int}{LanguageId}{}{
  Specifies the language ID in case of a string descriptor.
  For other descriptor types this value is not used and should be set to zero.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  Note that most USB devices do not implement the SET_DESCRIPTOR request.
  
  This function can only be used after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{GetDescriptor} \\
  \sa{GetDeviceDescriptor} \\
  \sa{GetConfigurationDescriptor} \\
  \sa{GetStringDescriptor} \\
  \sa{USBIOCOM_REQUEST_RECIPIENT} \\
  \sa{USBIOCOM_DESCRIPTOR_TYPE}
  }
\end{function}
\pagebreak
*/

    // configuration
    [id(17), helpstring("Add a USB interface to the configuration. The next call to SetConfiguration() activates this interface.")] 
    HRESULT AddInterface(
              [in] int InterfaceIndex,
              [in] int AlternateSettingIndex,
              [in] int MaximumTransferSize,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{AddInterface}{}{
  This function adds an interface to a list maintained internally by the USBIO COM object instance.
  }
  \param{[in] int}{InterfaceIndex}{}{
  Identifies the interface to be added.
  Valid values are defined by the device.
  Refer to the Universal Serial Bus Specification, Chapter~9 for more information.
  }
  \param{[in] int}{AlternateSettingIndex}{}{
  Identifies the alternate setting of the interface that shall be activated when the device is configured.
  Valid values are defined by the device.
  Refer to the Universal Serial Bus Specification, Chapter~9 for more information.
  }
  \param{[in] int}{MaximumTransferSize}{}{
  Specifies the maximum size, in bytes, of data transfers to or from endpoints of this interface.
  The value is user-defined and is valid for all endpoints of this interface. 
  If no special requirement exists a value of 4096 (4K) should be used.
  
  The buffer size used for read and write requests cannot exceed the \temph{MaximumTransferSize} value,
  see \hl{StartReading}, \hl{StartWriting}.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  AddInterface is used to prepare the configuration of the USB device which will be set by \hl{SetConfiguration}.
  AddInterface has to be called at least once before the device can be configured.
  It can be called several times to prepare all required interfaces.
  
  If a device supports more than one interface all of them have to be included in the configuration.
  Otherwise, the call to \hl{SetConfiguration} fails.
  Consequently, a call to AddInterface is required for each interface.
  
  The parameters passed to AddInterface are not checked immediately.
  If the parameters are not valid for the given device the subsequent call to \hl{SetConfiguration} will fail.
  
  This function can only be used after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{DeleteInterfaces} \\
  \sa{SetConfiguration} \\
  \sa{UnconfigureDevice} \\
  \sa{StartReading} \\
  \sa{StartWriting}
  }
\end{function}
\pagebreak
*/

    [id(18), helpstring("Delete all interfaces previously added by AddInterface.")] 
    HRESULT DeleteInterfaces();
/*doc
\begin{function}{}{ Method }{HRESULT}{DeleteInterfaces}{}{
  This function deletes all interfaces from the list maintained internally by the USBIO COM object instance.
  }
  \comments{
  All the interfaces previously added by means of \hl{AddInterface} will be deleted.
  The internal interface list is empty after this call.
  }
  \seealso{
  \sa{AddInterface} \\
  \sa{SetConfiguration} \\
  \sa{UnconfigureDevice}
  }
\end{function}
\pagebreak
*/

    [id(19), helpstring("Configure the USB device. At least one interface must be added first using AddInterface().")] 
    HRESULT SetConfiguration(
              [in] int ConfigurationIndex, 
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{SetConfiguration}{}{
  This function configures the USB device. 
  }
  \param{[in] int}{ConfigurationIndex}{}{
  Specifies the configuration to set.
  The value given here is the zero-based index of the configuration descriptor that is related to
  the configuration to be set.
  The index is used to query the associated configuration descriptor (GET_DESCRIPTOR request).
  The configuration value \tital{bConfiguration} that is contained in the configuration descriptor is used
  for the subsequent SET_CONFIGURATION request.
  
  For a single-configuration device the only valid value of \temph{ConfigurationIndex} is zero.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  This function configures the interfaces previously stored by means of the \hl{AddInterface} method.
  The parameters specified on the \hl{AddInterface} calls will be used.
  \hl{AddInterface} has to be called at least once before the device can be configured.
  
  The USB device has to be configured to activate its endpoints.
  After that, read and write operations can be performed.
  
  The following functions can only be used after the device has been configured:
  \hl{ResetDevice}, \hl{CyclePort}, \hl{SetDevicePowerState}.
  
  The device must be configured to use the remote wake up feature and to support the system suspend state.
  
  This function can only be used after the device was opened, see \hl{OpenDevice}.
  The device should be configured after the call to the \hl{OpenDevice} function.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{AddInterface} \\
  \sa{DeleteInterfaces} \\
  \sa{SetInterface} \\
  \sa{UnconfigureDevice} \\
  \sa{ResetDevice} \\
  \sa{CyclePort} \\
  \sa{SetDevicePowerState}
  }
\end{function}
\pagebreak
*/


    [id(20), helpstring("A GET_CONFIGURATION request is sent to the USB device. The current bConfigurationValue is returned, 0 means unconfigured.")] 
    HRESULT GetConfiguration(
              [out] unsigned char *ConfigurationValue,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{GetConfiguration}{}{
  This function retrieves the configuration currently set in the USB device.
  }
  \param{[out] unsigned char*}{ConfigurationValue}{}{
  A variable that receives the configuration value \tital{bConfiguration} defined by the 
  configuration descriptor that is related to the current configuration.
  
  The value 0 is returned if the USB device is not configured.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  This function can only be used after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{UnconfigureDevice}
  }
\end{function}
\pagebreak
*/

    [id(21), helpstring("Set the device to unconfigured state. Read and write operations will be stopped, all endpoints will be unbound.")] 
    HRESULT UnconfigureDevice(
              [out] int *Status
              );
/*doc ComIf
\begin{function}{}{ Method }{HRESULT}{UnconfigureDevice}{}{
  This function unconfigures the USB device.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  All pending read and write operations will be aborted.
  All endpoints will be unbound from USBIO COM object instances.
  
  This function can only be used after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration}
  }
\end{function}
\pagebreak
*/

    // interface, alternate setting
    [id(22), helpstring("A SET_INTERFACE request is sent to the device. A new alternate setting of the USB interface will be selected.")] 
    HRESULT SetInterface(
              [in] int InterfaceIndex,
              [in] int AlternateSettingIndex,
              [in] int MaximumTransferSize,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{SetInterface}{}{
  This function sets a new alternate setting for an interface and changes the maximum transfer size.
  }
  \param{[in] int}{InterfaceIndex}{}{
  Identifies the interface to be modified.
  Valid values are defined by the device.
  Refer to the Universal Serial Bus Specification, Chapter~9 for more information.
  }
  \param{[in] int}{AlternateSettingIndex}{}{
  Identifies the alternate setting of the interface to be set.
  Valid values are defined by the device.
  Refer to the Universal Serial Bus Specification, Chapter~9 for more information.
  }
  \param{[in] int}{MaximumTransferSize}{}{
  Specifies the maximum size, in bytes, of data transfers to or from endpoints of this interface.
  The value is user-defined and is valid for all endpoints of this interface. 
  If no special requirement exists a value of 4096 (4K) should be used.
  
  The buffer size used for read and write requests cannot exceed the 
  \temph{MaximumTransferSize} value, see \hl{StartReading}, \hl{StartWriting}.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  All read and write operations have to be stopped before this function is called.
  
  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{AddInterface} \\
  \sa{SetConfiguration} \\
  \sa{UnconfigureDevice} \\
  \sa{StartReading} \\
  \sa{StartWriting}
  }
\end{function}
\pagebreak
*/

    [id(23), helpstring("The current alternate setting of the interface is returned.")] 
    HRESULT GetInterface(
              [out] unsigned char *AlternateSetting,
              [in] int InterfaceIndex, 
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{GetInterface}{}{
  This function retrieves the current alternate setting of an interface.
  }
  \param{[out] unsigned char*}{AlternateSetting}{}{
  A variable that receives the current alternate setting.
  The values are defined by the device.
  Refer to the Universal Serial Bus Specification, Chapter~9 for more information.
  }
  \param{[in] int}{InterfaceIndex}{}{
  Identifies the interface.
  Valid values are defined by the device.
  Refer to the Universal Serial Bus Specification, Chapter~9 for more information.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{SetInterface}
  }
\end{function}
\pagebreak
*/

     // class or vendor requests
    [id(24), helpstring("A class or vendor specific request with an IN data stage is sent to the USB device.")] 
    HRESULT ClassOrVendorInRequest(
              [in,out] SAFEARRAY(unsigned char) *Buffer,
              [in,out] int *ByteCount, 
              [in] int Flags,
              [in] int Type,
              [in] int Recipient,
              [in] int RequestTypeReservedBits,
              [in] int Request,
              [in] int Value,
              [in] int Index,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{ClassOrVendorInRequest}{}{
  This function is used to generate a class or vendor specific device request (SETUP packet)
  with a data transfer phase in device to host (IN) direction.
  }
  \param{[in,out] SAFEARRAY(unsigned char)*}{Buffer}{}{
  An array type variable that receives the data transferred from the device in the data in phase.
  The caller has to provide this variable.
  The array will not be resized by the COM object.
  Consequently, the array has to provide enough storage for the data to be transferred.
  }
  \param{[in,out] int*}{ByteCount}{}{
  A variable that specifies the number of bytes to be transferred from the device in the data phase.
  This value is copied to the bytes 7 and 8 of the SETUP request.
  The byte count must not exceed 4096 and must be less than or equal to the number of bytes 
  provided in \temph{Buffer}.
  
  After the ClassOrVendorInRequest function succeeds the \temph{ByteCount} variable will be set to the
  number of bytes returned in the \temph{Buffer} array.
  }
  \param{[in] int}{Flags}{}{
  This field contains zero or the following value.
  \begin{description1}

    \item[USBIOCOM_SHORT_TRANSFER_OK]
    If this flag is set, the USBIO driver does not return an error if a data
    packet received from the device is shorter than the maximum packet size
    of the endpoint. Otherwise, a short packet causes an error condition.

  \end{description1}
  }
  \param{[in] int}{Type}{}{
  Specifies the type of the device request.
  The values are defined by the enumeration type \hl{USBIOCOM_REQUEST_TYPE}.
  A value of \temph{USBIOCOM_RequestTypeClass} generates a class-specific request and a value 
  of \temph{USBIOCOM_RequestTypeVendor} generates a vendor-specific request.
  }
  \param{[in] int}{Recipient}{}{
  Specifies the recipient of the device request.
  The values are defined by the enumeration type \hl{USBIOCOM_REQUEST_RECIPIENT}.
  }
  \param{[in] int}{RequestTypeReservedBits}{}{
  Specifies the reserved bits of the \tital{bmRequestType} field of the SETUP packet.
  Normally, this field is set to zero.
  }
  \param{[in] int}{Request}{}{
  Specifies the value of the \tital{bRequest} field of the SETUP packet.
  This is an 8 bit value.
  }
  \param{[in] int}{Value}{}{
  Specifies the value of the \tital{wValue} field of the SETUP packet.
  This is a 16 bit value.
  }
  \param{[in] int}{Index}{}{
  Specifies the value of the \tital{wIndex} field of the SETUP packet.
  This is a 16 bit value.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  The generated control request can be either a vendor-specific or a class-specific request.
  The request is sent to the default endpoint 0 (EP0) of the device.
  
  Note that this function cannot be used to generate standard USB requests.
  
  Refer to the Universal Serial Bus Specification, Chapter~9 for detailed information on
  the format of control requests.
  
  This function can only be used after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{ClassOrVendorOutRequest} \\
  \hl{USBIOCOM_REQUEST_TYPE} \\
  \hl{USBIOCOM_REQUEST_RECIPIENT}
  }
\end{function}
\pagebreak
*/

    [id(25), helpstring("A class or vendor specific request with an OUT data stage is sent to the USB device.")] 
    HRESULT ClassOrVendorOutRequest(
              [in,out] SAFEARRAY(unsigned char) *Buffer,
              [in] int Flags,
              [in] int Type,
              [in] int Recipient,
              [in] int RequestTypeReservedBits,
              [in] int Request,
              [in] int Value,
              [in] int Index,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{ClassOrVendorOutRequest}{}{
  This function is used to generate a class or vendor specific device request (SETUP packet)
  with a data transfer phase in host to device (OUT) direction.
  }
  \param{[in,out] SAFEARRAY(unsigned char)*}{Buffer}{}{
  An array type variable that provides the data to be sent in the data out phase.
  The size of the array defines the number of bytes to be transferred.
  }
  \param{[in] int}{Flags}{}{
  Should be set to zero.
  }
  \param{[in] int}{Type}{}{
  Specifies the type of the device request.
  The values are defined by the enumeration type \hl{USBIOCOM_REQUEST_TYPE}.
  A value of \temph{USBIOCOM_RequestTypeClass} generates a class-specific request and a value 
  of \temph{USBIOCOM_RequestTypeVendor} generates a vendor-specific request.
  }
  \param{[in] int}{Recipient}{}{
  Specifies the recipient of the device request.
  The values are defined by the enumeration type \hl{USBIOCOM_REQUEST_RECIPIENT}.
  }
  \param{[in] int}{RequestTypeReservedBits}{}{
  Specifies the reserved bits of the \tital{bmRequestType} field of the SETUP packet.
  Normally, this field is set to zero.
  }
  \param{[in] int}{Request}{}{
  Specifies the value of the \tital{bRequest} field of the SETUP packet.
  This is an 8 bit value.
  }
  \param{[in] int}{Value}{}{
  Specifies the value of the \tital{wValue} field of the SETUP packet.
  This is a 16 bit value.
  }
  \param{[in] int}{Index}{}{
  Specifies the value of the \tital{wIndex} field of the SETUP packet.
  This is a 16 bit value.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  The generated control request can be either a vendor-specific or a class-specific request.
  The request is sent to the default endpoint 0 (EP0) of the device.
  
  Note that this function cannot be used to generate standard USB requests.
  
  Refer to the Universal Serial Bus Specification, Chapter~9 for detailed information on
  the format of control requests.
  
  This function can only be used after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{ClassOrVendorInRequest} \\
  \hl{USBIOCOM_REQUEST_TYPE} \\
  \hl{USBIOCOM_REQUEST_RECIPIENT}
  }
\end{function}
\pagebreak
*/
    // feature requests
    [id(26), helpstring("A SET_FEATURE request is sent to the USB device.")] 
    HRESULT SetFeature(
              [in] int Recipient, 
              [in] int FeatureSelector, 
              [in] int Index,
              [out] int  *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{SetFeature}{}{
  This function is used to generate a SET_FEATURE device request.
  }
  \param{[in] int}{Recipient}{}{
  Specifies the recipient of the device request.
  The values are defined by the enumeration type \hl{USBIOCOM_REQUEST_RECIPIENT}.
  }
  \param{[in] int}{FeatureSelector}{}{
  Specifies the feature selector value for the set feature request.
  The values are defined by the recipient.
  Refer to the Universal Serial Bus Specification, Chapter~9 for more information.
  }
  \param{[in] int}{Index}{}{
  Specifies the index value for the set feature request.
  The values are defined by the device.
  Refer to the Universal Serial Bus Specification, Chapter~9 for more information.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  Refer to the Universal Serial Bus Specification, Chapter~9 for detailed information on
  the format of control requests.
  
  This function can only be used after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{ClearFeature} \\
  \sa{USBIOCOM_REQUEST_RECIPIENT}
  }
\end{function}
\pagebreak
*/

    [id(27), helpstring("A CLEAR_FEATURE request is sent to the USB device.")] 
    HRESULT ClearFeature(
              [in] int Recipient,
              [in] int FeatureSelector,
              [in] int Index,
              [out] int  *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{ClearFeature}{}{
  This function is used to generate a CLEAR_FEATURE device request.
  }
  \param{[in] int}{Recipient}{}{
  Specifies the recipient of the device request.
  The values are defined by the enumeration type \hl{USBIOCOM_REQUEST_RECIPIENT}.
  }
  \param{[in] int}{FeatureSelector}{}{
  Specifies the feature selector value for the clear feature request.
  The values are defined by the recipient.
  Refer to the Universal Serial Bus Specification, Chapter~9 for more information.
  }
  \param{[in] int}{Index}{}{
  Specifies the index value for the clear feature request.
  The values are defined by the device.
  Refer to the Universal Serial Bus Specification, Chapter~9 for more information.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  Refer to the Universal Serial Bus Specification, Chapter~9 for detailed information on
  the format of control requests.
  
  This function can only be used after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetFeature} \\
  \sa{USBIOCOM_REQUEST_RECIPIENT}
  }
\end{function}
\pagebreak
*/

    // power management
    [id(28), helpstring("Returns the current device power state.")] 
    HRESULT GetDevicePowerState(
              [out] int *DevicePowerState, 
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{GetDevicePowerState}{}{
  This function retrieves the current power state of the device.
  }
  \param{[out] int*}{DevicePowerState}{}{
  A variable that receives the current device power state.
  The values are defined by the enumeration type \hl{USBIOCOM_DEVICE_POWER_STATE}.
  The meaning of the values is defined by the Power Management specification.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  The device power state is maintained internally by the USBIO driver.
  This request can be used to query the current power state.
  
  This function can only be used after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetDevicePowerState} \\
  \sa{USBIOCOM_DEVICE_POWER_STATE}
  }
\end{function}
\pagebreak
*/    

    [id(29), helpstring("Sets the power state of the USB device.")] 
    HRESULT SetDevicePowerState(
              [in] int DevicePowerState, 
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{SetDevicePowerState}{}{
  This function sets a new device power state.
  }
  \param{[in] int}{DevicePowerState}{}{
  Specifies the device power state to be set.
  The values are defined by the enumeration type \hl{USBIOCOM_DEVICE_POWER_STATE}.
  The meaning of the values is defined by the Power Management specification.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  The device power state is maintained internally by the USBIO driver.
  This request can be used to change the power state.
  
  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{GetDevicePowerState} \\
  \sa{USBIOCOM_DEVICE_POWER_STATE}
  }
\end{function}
\pagebreak
*/    

    // other device-related requests
    [id(30), helpstring("Sends a USB reset to the device. The device must be configured before a reset can be issued.")] 
    HRESULT ResetDevice(
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{ResetDevice}{}{
  This function forces a USB reset at the hub port in which the device is plugged in.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  All pipes associated with the device will be unbound and all pending read and write operations will be cancelled.
  After ResetDevice is called the device is in the unconfigured state.
  
  If the device changes its USB descriptor set during a USB Reset the \hl{CyclePort}
  method should be used instead of this function.
  
  This request does not work if the system-provided multi-interface driver is used.
  
  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{CyclePort}
  }
\end{function}
\pagebreak
*/    

    [id(31), helpstring("Simulates a device disconnect/connect cycle. This will unload/load the USBIO driver. The device must be configured before this request can be issued.")] 
    HRESULT CyclePort(
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{CyclePort}{}{
  This function simulates a disconnect/connect cycle at the hub port in which the device is plugged in.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  The CyclePort function is similar to \hl{ResetDevice} except that from the software point of
  view a disconnect/connect cycle is simulated.
  This causes a re-enumeration of the device.
  The USBIO device driver is unloaded and then loaded again.
  
  After an application called this function it should close all instances open for the current device by 
  calling \hl{CloseDevice} with each of them.
  Then an enumeration of USB devices must be initiated again by using \hl{EnumerateDevices}.
  
  The CyclePort function should be used instead of \hl{ResetDevice} if the USB device modifies
  its descriptors during a USB reset.
  Particularly, this is required to implement the Device Firmware Upgrade (DFU) device class specification.
  Note that the USB device receives two USB resets after this call.
  This does not conform to the DFU specification.
  However, this is the standard device enumeration method used by the Windows USB bus driver (USBD).
  
  This request does not work if the system-provided multi-interface driver is used.
  
  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  }
  \seealso{
  \sa{EnumerateDevices} \\
  \sa{OpenDevice} \\
  \sa{CloseDevice} \\
  \sa{SetConfiguration} \\
  \sa{ResetDevice}
  }
\end{function}
\pagebreak
*/    

    [id(32), helpstring("Sends a GET_STATUS request to the device and returns the result.")] 
    HRESULT GetStatus(
              [out] int *StatusValue,
              [in] int Recipient,
              [in] int Index,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{GetStatus}{}{
  This function is used to generate a GET_STATUS device request.
  }
  \param{[out] int*}{StatusValue}{}{
  A variable that receives the status code that is returned by the recipient in response to
  the get status request.
  This is a 16 bit value.
  The meaning of the value is defined by the device.
  Refer to the Universal Serial Bus Specification, Chapter~9 for more information.
  }
  \param{[in] int}{Recipient}{}{
  Specifies the recipient of the device request.
  The values are defined by the enumeration type \hl{USBIOCOM_REQUEST_RECIPIENT}.
  }
  \param{[in] int}{Index}{}{
  Specifies the index value for the get status request.
  The values are defined by the device.
  Refer to the Universal Serial Bus Specification, Chapter~9 for more information.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  This function can only be used after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{USBIOCOM_REQUEST_RECIPIENT}
  }
\end{function}
\pagebreak
*/    

    [id(33), helpstring("Query the current USB frame number from the host controller.")] 
    HRESULT GetCurrentFrameNumber(
              [out] int *FrameNumber,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{GetCurrentFrameNumber}{}{
  This function retrieves the current value of the frame number counter maintained by the USB host controller driver.
  }
  \param{[out] int*}{FrameNumber}{}{
  A variable that receives the current frame number. 
  This is a 32 bit value.
  The 11 least significant bits correspond to the current frame number on the bus.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  This function can only be used after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice}
  }
\end{function}
\pagebreak
*/    

    [id(34), helpstring("Translate a USBIO specific error code to an error description text.")] 
    HRESULT ErrorText(
              [in] int Status, 
              [out,retval] BSTR *Text
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{ErrorText}{}{
  This function translates a private status code returned by the USBIO COM interface to an error text string.
  }
  \param{[in] int}{Status}{}{
  Specifies the status code to be translated.
  }
  \param{[out,retval] BSTR*}{Text}{}{
  The method returns the error text string that corresponds to the given status code.
  }
  \comments{
  The function translates private status codes only that are defined by 
  the USBIO device driver and the USBIO COM object.
  Those codes are listed in section~\ref{sec_errorcodes}.

  Note that USBIO private status codes range from 0xE0000000 to 0xE000FFFF.
  
  Status codes returned by Windows API functions cannot be translated by this function.
  }
\end{function}
\pagebreak
*/


    //
    // endpoint related operations
    // 

    // bind, unbind 
    [id(35), helpstring("Bind the object instance to an endpoint.")] 
    HRESULT Bind(
              [in] unsigned char EndpointAddress,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{Bind}{}{
  This function establishes a binding between the USBIO COM object instance and an endpoint.
  }
  \param{[in] unsigned char}{EndpointAddress}{}{
  Specifies the address of the endpoint to bind the object instance to.
  The endpoint address is specified as reported in the corresponding endpoint descriptor.
  
  The endpoint address includes the direction flag at bit position 7 (MSB).
  \begin{tabular}{ll}
      Bit 7 = 0:  & OUT endpoint\\
      Bit 7 = 1:  & IN endpoint\\
  \end{tabular}

  Refer to the Universal Serial Bus Specification, Chapter~9 for more information.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  A USBIO COM object instance can be bound to one endpoint only.
  Consequently, one object instance has to be created for each active endpoint.
  
  Only active endpoints from the current configuration can be bound.
  
  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  
  After the USBIO COM object instance has been successfully bound to an endpoint data 
  transfer operations can be initiated for this endpoint, see \hl{StartReading} and \hl{StartWriting}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{Unbind} \\
  \sa{StartReading} \\
  \sa{StartWriting}
  }
\end{function}
\pagebreak
*/    

    [id(36), helpstring("Unbind the object instance from an endpoint.")] 
    HRESULT Unbind(
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{Unbind}{}{
  This function deletes the binding between the USBIO COM object instance and an endpoint.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  All read and write operations related to the bound endpoint will be stopped.
  
  After a call to Unbind the USBIO COM object instance can be bound to an endpoint again 
  by another call to \hl{Bind}.
  
  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{Bind}
  }
\end{function}
\pagebreak
*/    

    // read requests
    [id(37), helpstring("Initiate a continuous data transfer from the endpoint attached by a call to Bind()")] 
    HRESULT StartReading(
              [in] int SizeOfBuffer_IsoFramesInBuffer, 
              [in] int NumberOfBuffers,
              [in] int MaxErrorCount,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{StartReading}{}{
  This function starts an internal worker-thread that performs a continuous data transfer from
  the endpoint that is attached to the USBIO COM object instance.
  }
  \param{[in] int}{SizeOfBuffer_IsoFramesInBuffer}{}{
  The meaning of this parameter depends on the type of the endpoint.
  \begin{description1}

    \item[Bulk or Interrupt Endpoint]
    If the endpoint is of type bulk or interrupt this parameter specifies the size, in bytes, 
    of the read buffers used internally by the worker-thread.
    The read buffer size cannot exceed the maximum transfer size configured for the endpoint.
    The maximum transfer size is specified on a call to \hl{AddInterface} or \hl{SetInterface}.
    
    The buffer size should be a multiple of the endpoint's FIFO size.
    Otherwise, buffer overrun errors can occur.
    
    \vspace{2mm}
    \item[Isochronous Endpoint]
    If the endpoint is of type isochronous this parameter specifies the number of isochronous frames in a buffer.
    The size of a read buffer, in bytes, is the product of \temph{SizeOfBuffer_IsoFramesInBuffer} and the
    FIFO size of the endpoint. 
    The read buffer size cannot exceed the maximum transfer size configured for the endpoint, otherwise
    the error code \temph{USBIO_ERR_INVALID_PARAMETER} will be returned.
    The maximum transfer size is specified in a call to \hl{AddInterface} or \hl{SetInterface}.
    
    The value of \temph{SizeOfBuffer_IsoFramesInBuffer} should be in the range 16..64.
    See the comments below for further information.

  \end{description1}
  }
  \param{[in] int}{NumberOfBuffers}{}{
  This parameter specifies the number of buffers to be allocated internally by the worker-thread.
  The value of \temph{NumberOfBuffers} should be in the range 5..50.
  See the comments below for further information.
  }
  \param{[in] int}{MaxErrorCount}{}{
  This parameter specifies the maximum value of an error counter that is maintained internally
  by the worker-thread.
  Each time a data transfer is completed with an error the error counter will be incremented.
  If the counter reaches the \temph{MaxErrorCount} value the worker-thread will stop.
  The error counter is reset to zero on each successful data transfer operation.
  This way, the worker-thread will be stopped automatically if a device constantly causes errors.
  Thus, an end-less loop causing a high CPU load will be avoided in this situation.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  The function allocates an internal pool of buffers to be used for the data transfer from
  the device's endpoint to the host.
  The size of each buffer and the number of buffers to allocate is specified by means of the parameters
  \temph{SizeOfBuffer_IsoFramesInBuffer} and \temph{NumberOfBuffers}.
  
  In case of a bulk or interrupt endpoint the buffer size and the total amount of memory to allocate 
  is calculated as follows.
  
  \hspace{5mm}\tital{BufferSize = SizeOfBuffer_IsoFramesInBuffer}\\
  \hspace{5mm}\tital{TotalSize = NumberOfBuffers * BufferSize}
  \vspace{2mm}

  In case of an isochronous endpoint the buffer size and the total amount of memory to allocate 
  is calculated as follows.

  \hspace{5mm}\tital{BufferSize = SizeOfBuffer_IsoFramesInBuffer * EndpointFifoSize}\\
  \hspace{5mm}\tital{TotalSize = NumberOfBuffers * BufferSize}
  \vspace{2mm}

  In case of an isochronous transfer the parameter \temph{SizeOfBuffer_IsoFramesInBuffer} should be
  choosen carefully.
  Because it specifies the number of isochronous data frames to be placed in a buffer the parameter
  has an impact on the delay that will occur in the data path.
  In full-speed mode, one isochronous data frame per millisecond is received by the host, 
  but the application will not receive the buffer until it is completely filled with isochronous frames.
  Thus, large buffers cause a delay.
  
  On the other hand, a small number of isochronous data frames per buffer will cause a high CPU load
  because the interval of buffer completion events is very short.
  A PC is not able to handle events efficiently at an interval of one or two milliseconds.
  
  The isochronous data transmission is more stable when larger buffers are used because this is
  more tolerant regarding thread latencies.
  If the buffers are too small and the CPU is busy with other tasks transmission errors like
  \temph{USBIO_ERR_BAD_START_FRAME} can occur.
  
  An application has to find a compromise for the size of isochronous buffers.
  In full-speed mode, a value of 16 to 64 isochronous data frames per buffer is recommended.
  However, the following limitations should be considered.

  On Windows~98 and Windows~98~SE the number of isochronous data frames per buffer must be 
  less than or equal 32 (see also problems.txt in the USBIO package).

  Because of a limitation of the system-provided USB host controller driver 
  the product of \temph{SizeOfBuffer_IsoFramesInBuffer} and \temph{NumberOfBuffers} cannot exceed 1024.
  If this condition is not met the error code \temph{USBIO_ERR_BAD_START_FRAME} is returned by the 
  function \hl{ReadIsoData}.

  After the buffer pool was successfully allocated the function starts an internal worker-thread
  that handles the data transfer by means of asynchronous (overlapped) read requests.
  The thread implements a circulation of buffers.
  This way, it ensures that a continuous data transfer from the device is possible.
  
  After the worker-thread is started the USB host sends IN tokens to the endpoint that is attached
  to the USBIO COM object instance.
  
  When a data buffer is received from the device the worker-thread issues a \hl{ReadComplete} event.
  The application should implement a handler for this event and when it is received read the data
  from the USBIO COM object instance by calling \hl{ReadData} or \hl{ReadIsoData} depending on the type
  of the endpoint.

  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  Furthermore, the object instance must have been bound to an endpoint, see \hl{Bind}.
  
  {\bf Important:} This function must not be called from the context of the following event handler
  functions: \hl{ReadComplete}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{Bind} \\
  \sa{ReadData} \\
  \sa{ReadIsoData} \\
  \sa{ReadComplete} \\
  \sa{StopReading}
  }
\end{function}
\pagebreak
*/    

    [id(38), helpstring("Read data received from an endpoint. Should be called when the ReadComplete event is issued.")] 
    HRESULT ReadData(
              [in,out] SAFEARRAY(unsigned char) *Buffer,
              [out] int *ByteCount,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{ReadData}{}{
  This function is used to read the data received from a bulk or interrupt endpoint.
  }
  \param{[in,out] SAFEARRAY(unsigned char)*}{Buffer}{}{
  An array type variable that receives the data bytes.
  The caller has to provide this variable.
  The array will not be resized by the COM object.
  Consequently, the array has to provide enough storage for the data.
  }
  \param{[out] int*}{ByteCount}{}{
  A variable that specifies the number of bytes to read.
  This number has to be greater than zero and less than or equal than the number of bytes provided in \temph{Buffer}.

  After the ReadData function succeeds the \temph{ByteCount} variable will be set to the
  number of bytes returned in the \temph{Buffer} array.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  The function reads the received data from the intermediate storage that is maintained internally by 
  the worker-thread.
  It does never block and wait for data to be received from the device.
  If no data is available the function returns immediately with a status code of \temph{USBIO_ERR_NO_DATA}.

  ReadData should be called when the application receives the event \hl{ReadComplete} 
  indicating that data is available.
  There is no need to call this function periodically (polling).
  This would cause an unnecessary CPU load.
  The USBIO COM object instance issues a \hl{ReadComplete} event each time data becomes available.
  
  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  Furthermore, the object instance must have been bound to an endpoint, see \hl{Bind}, and
  the internal worker-thread must have been started, see \hl{StartReading}.
  
  This function should not be used after a call to \hl{StopReading}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{Bind} \\
  \sa{StartReading} \\
  \sa{StopReading} \\
  \sa{ReadComplete} \\
  \sa{ReadIsoData} \\
  \sa{ResetPipe}
  }
\end{function}
\pagebreak
*/    

    [id(39), helpstring("Read data received from an isochronous endpoint. Should be called when the ReadComplete event is issued.")] 
    HRESULT ReadIsoData(
              [in,out] SAFEARRAY(unsigned char) *Buffer,
              [out] int *ByteCount,
              [in,out] SAFEARRAY(int) *SubBufferLength_ErrorCode,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{ReadIsoData}{}{
  This function is used to read the data received from an isochronous endpoint.
  }
  \param{[in,out] SAFEARRAY(unsigned char)*}{Buffer}{}{
  An array type variable that receives the data bytes.
  The caller has to provide this variable.
  The array will not be resized by the COM object.
  Consequently, the array has to provide enough storage for the data.
  }
  \param{[out] int*}{ByteCount}{}{
  A variable that specifies the number of bytes to read.
  This number has to be less than or equal than the number of bytes provided in \temph{Buffer}.
  
  After the ReadIsoData function succeeds the \temph{ByteCount} variable will be set to the
  number of bytes returned in the \temph{Buffer} array.
  }
  \param{[in,out] SAFEARRAY(int)*}{SubBufferLength_ErrorCode}{}{
  An array type variable that receives additional information on the isochronous frames received.
  The caller has to provide this variable.
  The array will not be resized by the COM object.
  Consequently, the array has to provide enough storage.
  
  The array has to provide one integer per isochronous frame in the buffer.
  Therefore, the dimension of the array has to be equal or greater than the parameter 
  \temph{SizeOfBuffer_IsoFramesInBuffer} passed to \hl{StartReading}.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.

  Note that even if success is returned the data transfer of one or more isochronous frames
  could have been failed.
  In order to retrieve the status of single frames the contents of \temph{SubBufferLength_ErrorCode}
  has to be examined.
  }
  \comments{
  The function reads the received data from the intermediate storage that is maintained internally by 
  the worker-thread.
  It does never block and wait for data to be received from the device.
  If no data is available the function returns immediately with a status code of \temph{USBIO_ERR_NO_DATA}.

  ReadIsoData should be called when the application receives the event \hl{ReadComplete} 
  indicating that data is available.
  There is no need to call this function periodically (polling).
  This would cause an unnecessary CPU load.
  The USBIO COM object instance issues a \hl{ReadComplete} event each time data becomes available.

  The function places the received isochronous frames contiguous in the array provided at \temph{Buffer}.
  There will be no gaps between the frames. 
  Note that the length of the frames varies.
  An application should examine the values returned in the \temph{SubBufferLength_ErrorCode} array 
  to learn about the length of each single frame.
  
  The function returns an integer value per isochronous frame in the array provided
  at \temph{SubBufferLength_ErrorCode}.
  The integer value provides status information on the corresponding frame.
  If the value is greater than or equal to zero the frame was received successfully.
  In this case, the integer value is the length of the isochronous data frame, in bytes.
  Note that the length of the frame can be zero. 
  This is not an error.
  \\ If the value is negative the corresponding frame was received with error.
  In this case, the integer value is an error code.
  
  Frames that were received with error will not be copied to the \temph{Buffer} array.

  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  Furthermore, the object instance must have been bound to an endpoint, see \hl{Bind}, and
  the internal worker-thread must have been started, see \hl{StartReading}.
  
  This function should not be used after a call to \hl{StopReading}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{Bind} \\
  \sa{StartReading} \\
  \sa{StopReading} \\
  \sa{ReadComplete} \\
  \sa{ReadData}
  }
\end{function}
\pagebreak
*/    

    [id(40), helpstring("Stops the data transfer from an endpoint.")] 
    HRESULT StopReading();
/*doc
\begin{function}{}{ Method }{HRESULT}{StopReading}{}{
  This function stops the internal worker-thread that performs a continuous data transfer from
  the endpoint that is attached to the USBIO COM object instance.
  }
  \comments{
  After the worker-thread is stopped no further IN tokens will be send to the endpoint that is attached
  to the USBIO COM object instance.
  
  {\bf Important:} This function must not be called from the context of the following event handler
  functions: \hl{ReadComplete}.
  }
  \seealso{
  \sa{StartReading} \\
  \sa{ReadData} \\
  \sa{ReadIsoData}
  }
\end{function}
\pagebreak
*/    

    // write requests
    [id(41), helpstring("Initiate a continuous data transfer to the endpoint attached by a call to Bind()")] 
    HRESULT StartWriting(
              [in] int SizeOfBuffer_IsoFramesInBuffer,
              [in] int NumberOfBuffers,
              [in] int MaxErrorCount,
              [in] BOOL WriteStatus, 
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{StartWriting}{}{
  This function starts an internal worker-thread that performs a continuous data transfer to 
  the endpoint that is attached to the USBIO COM object instance.
  }
  \param{[in] int}{SizeOfBuffer_IsoFramesInBuffer}{}{
  The meaning of this parameter depends on the type of the endpoint.
  \begin{description1}

    \item[Bulk or Interrupt Endpoint]
    If the endpoint is of type bulk or interrupt this parameter specifies the size, in bytes, 
    of the write buffers used internally by the worker-thread.
    The write buffer size cannot exceed the maximum transfer size configured for the endpoint.
    The maximum transfer size is specified on a call to \hl{AddInterface} or \hl{SetInterface}.

    \vspace{2mm}
    \item[Isochronous Endpoint]
    If the endpoint is of type isochronous this parameter specifies the number of isochronous frames in a buffer.
    The size of a write buffer, in bytes, is the product of \temph{SizeOfBuffer_IsoFramesInBuffer} and the
    FIFO size of the endpoint. 
    The write buffer size cannot exceed the maximum transfer size configured for the endpoint, otherwise
    the error code \temph{USBIO_ERR_INVALID_PARAMETER} will be returned.
    The maximum transfer size is specified in a call to \hl{AddInterface} or \hl{SetInterface}.
    
    The value of \temph{SizeOfBuffer_IsoFramesInBuffer} should be in the range 16..64.
    See the comments below for further information.

  \end{description1}
  }
  \param{[in] int}{NumberOfBuffers}{}{
  This parameter specifies the number of buffers to be allocated internally by the worker-thread.
  The value of \temph{NumberOfBuffers} should be in the range 5..50.
  See the comments below for further information.
  }
  \param{[in] int}{MaxErrorCount}{}{
  This parameter specifies the maximum value of an error counter that is maintained internally
  by the worker-thread.
  Each time a data transfer is completed with an error the error counter will be incremented.
  If the counter reaches the \temph{MaxErrorCount} value the worker-thread will stop.
  The error counter is reset to zero on each successful data transfer operation.
  This way, the worker-thread will be stopped automatically if a device constantly causes errors.
  Thus, an end-less loop causing a high CPU load will be avoided in this situation.
  }
  \param{[in] BOOL}{WriteStatus}{}{
  This parameter indicates whether the application wants to be informed on the completion status
  of each write operation.

  If \temph{WriteStatus} is set to TRUE the application has to implement a handler for
  the event \hl{WriteStatusAvailable}.
  This event will be issued by the USBIO COM object instance after a write operation has been completed
  and the completion status of the operation is available.
  The application retrieves the status code by calling \hl{GetWriteStatus} or \hl{GetIsoWriteStatus},
  depending on the type of the endpoint.
  \\ Note that if TRUE is specified the application is required to process the status codes by using 
  \hl{GetWriteStatus} or \hl{GetIsoWriteStatus} to free the buffers and make them available for
  further write operations.

  If \temph{WriteStatus} is set to FALSE the application does not need to implement a handler for
  the event \hl{WriteStatusAvailable}.
  The application will not be informed on the completion status of write operations.
  It does not call \hl{GetWriteStatus} or \hl{GetIsoWriteStatus}.
  \\ The buffers will be freed automatically after the write operation has been completed, 
  regardless of the completion status.
  Thus, the buffers become available for further write operations.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  The function allocates an internal pool of buffers to be used for the data transfer from
  the host to the device's endpoint.
  The size of each buffer and the number of buffers to allocate is specified by means of the parameters
  \temph{SizeOfBuffer_IsoFramesInBuffer} and \temph{NumberOfBuffers}.
  
  In case of a bulk or interrupt endpoint the buffer size and the total amount of memory to allocate 
  is calculated as follows.

  \hspace{5mm}\tital{BufferSize = SizeOfBuffer_IsoFramesInBuffer}\\
  \hspace{5mm}\tital{TotalSize = NumberOfBuffers * BufferSize}
  \vspace{2mm}

  In case of an isochronous endpoint the buffer size and the total amount of memory to allocate 
  is calculated as follows.

  \hspace{5mm}\tital{BufferSize = SizeOfBuffer_IsoFramesInBuffer * EndpointFifoSize}\\
  \hspace{5mm}\tital{TotalSize = NumberOfBuffers * BufferSize}
  \vspace{2mm}

  In case of an isochronous transfer the parameter \temph{SizeOfBuffer_IsoFramesInBuffer} should be
  choosen carefully.
  Because it specifies the number of isochronous data frames placed in a buffer the parameter
  has an impact on the delay that will occur in the data path.
  In full-speed mode, one isochronous data frame per millisecond is sent by the host, 
  but the application has to provide buffers that are completely filled with isochronous frames.
  Thus, large buffers cause a delay.
  
  On the other hand, a small number of isochronous data frames per buffer will cause a high CPU load
  because the interval of buffer completion events is very short.
  A PC is not able to handle events efficiently at an interval of one or two milliseconds.
  
  The isochronous data transmission is more stable when larger buffers are used because this is
  more tolerant regarding thread latencies.
  If the buffers are too small and the CPU is busy with other tasks transmission errors like
  \temph{USBIO_ERR_BAD_START_FRAME} can occur.
  
  An application has to find a compromise for the size of isochronous buffers.
  For full-speed mode a value of 16 to 64 isochronous data frames per buffer is recommended.
  However, the following limitations should be considered.

  On Windows~98 and Windows~98~SE the number of isochronous data frames per buffer must be 
  less than or equal 32 (see also problems.txt in the USBIO package).

  Because of a limitation of the system-provided USB host controller driver 
  the product of \temph{SizeOfBuffer_IsoFramesInBuffer} and \temph{NumberOfBuffers} cannot exceed 1024.
  If this condition is not met the error code \temph{USBIO_ERR_BAD_START_FRAME} is returned by the 
  function \hl{ReadIsoData}.

  After the buffer pool was successfully allocated the function starts an internal worker-thread
  that handles the data transfer by means of asynchronous (overlapped) write requests.
  The thread implements a circulation of buffers.
  This way, it ensures that a continuous data transfer to the device is possible.
  
  After the worker-thread is started it waits until the application calls \hl{WriteData} or 
  \hl{WriteIsoData}, depending on the type of the endpoint.
  Then the thread initiates write operations.
  This causes the USB host to start sending OUT tokens to the endpoint that is attached
  to the USBIO COM object instance.

  An application provides data to be transferred to the device by calling \hl{WriteData} or 
  \hl{WriteIsoData} in a loop until the error code \temph{USBIO_ERR_NO_BUFFER} is returned.
  This indicates that the internal buffer space is exhausted.
  The application stops writing data.
  
  When a write operation is completed and a free buffer becomes available the worker-thread issues
  a \hl{WriteComplete} event.
  The application should implement a handler for this event and when it is received continue to write data
  by calling \hl{WriteData} or \hl{WriteIsoData} in a loop again.
  
  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  Furthermore, the object instance must have been bound to an endpoint, see \hl{Bind}.
  
  {\bf Important:} This function must not be called from the context of the following event handler
  functions: \hl{WriteComplete}, \hl{WriteStatusAvailable}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{Bind} \\
  \sa{WriteData} \\
  \sa{GetWriteStatus} \\
  \sa{WriteIsoData} \\
  \sa{GetIsoWriteStatus} \\
  \sa{WriteComplete} \\
  \sa{StopWriting}
  }
\end{function}
\pagebreak
*/    

    [id(42), helpstring("Write data to be send to an endpoint.")] 
    HRESULT WriteData(
              [in,out] SAFEARRAY(unsigned char) *Buffer, 
              [in] int UserId,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{WriteData}{}{
  This function is used to write data to be send to a bulk or interrupt endpoint.
  }
  \param{[in,out] SAFEARRAY(unsigned char)*}{Buffer}{}{
  An array type variable that provides the data to be written.
  The size of the array determines the number of bytes to write.
  Note that writing of zero bytes is possible.
  This will result in a zero packet sent to the endpoint.
  
  The number of bytes in \temph{Buffer} cannot exceed the size of a write buffer specified in 
  \temph{SizeOfBuffer_IsoFramesInBuffer} at the call to \hl{StartWriting}.
  }
  \param{[in] int}{UserId}{}{
  This parameter specifies an application-defined ID that can be used to identify the write buffer
  in a later call to \hl{GetWriteStatus}.
  
  If an application does not implement processing of write completion status codes 
  this parameter should be set to zero.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  
  Note that the value returned is not the final completion status of the write operation.
  The write operation can fail even if the returned status of this function indicates success.
  In order to retrieve the completion status of the write operation \hl{GetWriteStatus} has to be used.
  }
  \comments{
  The function copies the provided data to the intermediate storage that is maintained internally by 
  the worker-thread.
  It does never block and wait until data is sent to the device.
  If no intermediate buffer space is available the function returns immediately with a status code 
  of \temph{USBIO_ERR_NO_BUFFER}.

  WriteData should be called again when the application receives the event \hl{WriteComplete} 
  indicating that buffer space is available.
  There is no need to call this function periodically (polling).
  This would cause an unnecessary CPU load.
  The USBIO COM object instance issues a \hl{WriteComplete} event each time a buffer becomes available.
  
  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  Furthermore, the object instance must have been bound to an endpoint, see \hl{Bind}, and
  the internal worker-thread must have been started, see \hl{StartWriting}.
  
  This function should not be used after a call to \hl{StopWriting}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{Bind} \\
  \sa{StartWriting} \\
  \sa{StopWriting} \\
  \sa{GetWriteStatus} \\
  \sa{WriteComplete} \\
  \sa{WriteIsoData} \\
  \sa{ResetPipe}
  }
\end{function}
\pagebreak
*/    

    [id(43), helpstring("Query the completion status of a write operation. Should be called when the WriteStatusAvailable event is issued.")] 
    HRESULT GetWriteStatus(
              [out] int *UserId, 
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{GetWriteStatus}{}{
  This function is used to retrieve the completion status of a write operation to a bulk or interrupt endpoint.
  }
  \param{[out] int*}{UserId}{}{
  A variable that receives the application-defined ID that was passed to \hl{WriteData}.
  An application can use this ID to identify the write buffer.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the final completion status of the write operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  This function can be used only if the parameter \temph{WriteStatus} was set to TRUE at the call to \hl{StartWriting}.
  See \hl{StartWriting} for more information.

  GetWriteStatus should be called when the application receives the event \hl{WriteStatusAvailable} 
  indicating that a write operation has been completed.
  There is no need to call this function periodically (polling).
  This would cause an unnecessary CPU load.
  The USBIO COM object instance issues a \hl{WriteStatusAvailable} event each time a write operation gets completed.

  After the call to GetWriteStatus returns the internal write buffer is marked as free and the event
  \hl{WriteComplete} will be issued by the USBIO COM object instance.

  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  Furthermore, the object instance must have been bound to an endpoint, see \hl{Bind}, and
  the internal worker-thread must have been started, see \hl{StartWriting}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{Bind} \\
  \sa{StartWriting} \\
  \sa{StopWriting} \\
  \sa{WriteData} \\
  \sa{WriteStatusAvailable} \\
  \sa{WriteComplete}
  }
\end{function}
\pagebreak
*/    

    [id(44), helpstring("Write data to be send to an isochronous endpoint.")] 
    HRESULT WriteIsoData(
              [in,out] SAFEARRAY(unsigned char) *Buffer,
              [in,out] SAFEARRAY(int) *SubBufferLength,
              [in] int UserId,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{WriteIsoData}{}{
  This function is used to write data to be send to an isochronous endpoint.
  }
  \param{[in,out] SAFEARRAY(unsigned char)*}{Buffer}{}{
  An array type variable that provides the data to be written.
  The size of the array must be equal to the sum of all values passed in the array \temph{SubBufferLength}.
  }
  \param{[in,out] SAFEARRAY(int)*}{SubBufferLength}{}{
  An array type variable that specifies the length of each isochronous data frame to be transmitted.
  The caller has to provide this variable.
  
  The array contains one integer per isochronous frame in the buffer.
  Therefore, the dimension of the array has to be equal to the parameter 
  \temph{SizeOfBuffer_IsoFramesInBuffer} passed to \hl{StartWriting}.
  The integer value specifies the length of the corresponding isochronous data frame.
  See also the comments below.
  }
  \param{[in] int}{UserId}{}{
  This parameter specifies an application-defined ID that can be used to identify the write buffer
  in a later call to \hl{GetIsoWriteStatus}.
  
  If an application does not implement processing of write completion status codes 
  this parameter should be set to zero.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  
  Note that the value returned is not the final completion status of the write operation.
  The write operation can fail even if the returned status of this function indicates success.
  In order to retrieve the completion status of the write operation \hl{GetIsoWriteStatus} has to be used.
  }
  \comments{
  The function copies the provided data to the intermediate storage that is maintained internally by 
  the worker-thread.
  It does never block and wait until data is sent to the device.
  If no intermediate buffer space is available the function returns immediately with a status code 
  of \temph{USBIO_ERR_NO_BUFFER}.

  WriteIsoData should be called again when the application receives the event \hl{WriteComplete} 
  indicating that buffer space is available.
  There is no need to call this function periodically (polling).
  This would cause an unnecessary CPU load.
  The USBIO COM object instance issues a \hl{WriteComplete} event each time a buffer becomes available.

  The function expects the isochronous frames to be transmitted contiguous in the array provided at \temph{Buffer}.
  There must be no gaps between the frames. 
  Note that the length of the frames can vary.
  An application has to specify the length of each frame in the \temph{SubBufferLength} array.

  The array provided at \temph{SubBufferLength} contains an integer value per isochronous data frame.
  This value specifies the length of the corresponding frame, in bytes.
  The length of an isochronous data frame can be zero.
  But, at least one frame in the buffer must have a length greater than zero.
  In other words, the total number of bytes in a buffer must not be zero.

  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  Furthermore, the object instance must have been bound to an endpoint, see \hl{Bind}, and
  the internal worker-thread must have been started, see \hl{StartWriting}.
  
  This function should not be used after a call to \hl{StopWriting}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{Bind} \\
  \sa{StartWriting} \\
  \sa{StopWriting} \\
  \sa{GetIsoWriteStatus} \\
  \sa{WriteComplete} \\
  \sa{WriteData}
  }
\end{function}
\pagebreak
*/    

    [id(45), helpstring("Query the completion status of a write operation. Should be called when the WriteStatusAvailable event is issued.")] 
    HRESULT GetIsoWriteStatus(
              [out] int *UserId,
              [in,out] SAFEARRAY(int) *StatusArray,
              [out] int *FrameCount, 
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{GetIsoWriteStatus}{}{
  This function is used to retrieve the completion status of a write operation to an isochronous endpoint.
  }
  \param{[out] int*}{UserId}{}{
  A variable that receives the application-defined ID that was passed to \hl{WriteIsoData}.
  An application can use this ID to identify the write buffer.
  }
  \param{[in,out] SAFEARRAY(int)*}{StatusArray}{}{
  An array type variable that receives status information on the isochronous frames transmitted.
  The caller has to provide this variable.
  The array will not be resized by the COM object.
  Consequently, the array has to provide enough storage.
  
  The array has to provide one integer per isochronous frame in the buffer.
  Therefore, the dimension of the array has to be equal or greater than the parameter 
  \temph{SizeOfBuffer_IsoFramesInBuffer} passed to \hl{StartWriting}.
  }
  \param{[out] int*}{FrameCount}{}{
  A variable that will be set to the number of valid fields returned in \temph{StatusArray}.
  This corresponds to the number of frames passed to \hl{WriteIsoData}.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  
  Note that the value returned is not the completion status of the isochronous write operation.
  To learn about the write completion status the values returned in \temph{StatusArray} have to be examined.
  }
  \comments{
  This function can be used only if the parameter \temph{WriteStatus} was set to TRUE at the call to \hl{StartWriting}.
  See \hl{StartWriting} for more information.

  GetIsoWriteStatus should be called when the application receives the event \hl{WriteStatusAvailable} 
  indicating that a write operation has been completed.
  There is no need to call this function periodically (polling).
  This would cause an unnecessary CPU load.
  The USBIO COM object instance issues a \hl{WriteStatusAvailable} event each time a write operation gets completed.

  After the call to GetIsoWriteStatus returns the internal write buffer is marked as free and the event
  \hl{WriteComplete} will be issued by the USBIO COM object instance.

  In the caller-provided \temph{StatusArray} GetIsoWriteStatus returns an integer value per isochronous frame transmitted.
  The integer value is the completion status of the transmission of the corresponding frame.
  If the value is zero the frame was transmitted successfully.
  If an error occurred the value is one of the USBIO status codes listed in section~\ref{sec_errorcodes}.

  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  Furthermore, the object instance must have been bound to an endpoint, see \hl{Bind}, and
  the internal worker-thread must have been started, see \hl{StartWriting}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{Bind} \\
  \sa{StartWriting} \\
  \sa{StopWriting} \\
  \sa{WriteIsoData} \\
  \sa{WriteStatusAvailable} \\
  \sa{WriteComplete}
  }
\end{function}
\pagebreak
*/    

    [id(46), helpstring("Stops the data transfer to an endpoint.")] 
    HRESULT StopWriting();
/*doc
\begin{function}{}{ Method }{HRESULT}{StopWriting}{}{
  This function stops the internal worker-thread that performs a continuous data transfer to 
  the endpoint that is attached to the USBIO COM object instance.
  }
  \comments{
  After the worker-thread is stopped no further OUT tokens will be send to the endpoint that is attached
  to the USBIO COM object instance.

  Note that the data that is maintained internally by the worker-thread but not yet sent to the device
  will be discarded by this call.

  {\bf Important:} This function must not be called from the context of the following event handler
  functions: \hl{WriteComplete}, \hl{WriteStatusAvailable}.
  }
  \seealso{
  \sa{StartWriting} \\
  \sa{WriteData} \\
  \sa{WriteIsoData}
  }
\end{function}
\pagebreak
*/    

    // pipe control
    [id(47), helpstring("Clears an error condition on a pipe. A CLEAR_FEATURE(ENDPOINT_STALL) request is sent to bulk and interrupt endpoints.")] 
    HRESULT ResetPipe(
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{ResetPipe}{}{
  This function clears an error condition on an endpoint.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  If an error occurs while transferring data from or to a bulk, interrupt, or isochronous endpoint
  the associated data pipe will be halted by the USB driver.
  No further data transfers on the pipe are possible.
  To clear this error condition and continue transferring data ResetPipe has to be called in this situation.

  It is recommended to call this function before a read or write transfer is started by means of
  \hl{StartReading} or \hl{StartWriting}.

  In case of a bulk or interrupt endpoint a call to this function causes a CLEAR_FEATURE(ENDPOINT_STALL) request
  to be send to the device.

  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  Furthermore, the object instance must have been bound to an endpoint, see \hl{Bind}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{Bind} \\
  \sa{StartReading} \\
  \sa{StartWriting}
  }
\end{function}
\pagebreak
*/    

    [id(48), helpstring("All pending I/O operations will be aborted on the pipe.")] 
    HRESULT AbortPipe(
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{AbortPipe}{}{
  This function aborts all read and write operations currently in progress in the USBIO COM object instance.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  All outstanding read or write requests on the attached pipe are aborted and returned with an error status of
  \temph{USBIO_ERR_CANCELED}.
  This will interrupt data transfers currently in progress.

  This function should not be used on isochronous pipes.
  This can cause a system crash when the system-provided Open Host Controller driver is used.
  See also \tital{Problems.txt} in the USBIO package.

  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  Furthermore, the object instance must have been bound to an endpoint, see \hl{Bind}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{Bind} \\
  \sa{StartReading} \\
  \sa{StartWriting}
  }
\end{function}
\pagebreak
*/    


    // pipe options
    [propget, id(49), helpstring("Get the current state of the ShortTransferOK flag for the pipe.")] 
    HRESULT ShortTransferOK([out, retval] BOOL *ShortTransfer);
/*doc
\begin{function}{}{ Property }{HRESULT}{ShortTransferOK}{}{
  Reading this property returns TRUE if a data transfer shorter than the endpoint's FIFO size
  does not cause an error, FALSE otherwise.
  See below for a detailed description.
  }
  \param{[out,retval] BOOL*}{ShortTransfer}{}{
  A variable that will be set to TRUE or FALSE.
  }
\end{function}
*/
    [propput, id(49), helpstring("Sets or clears the ShortTransferOK flag for the pipe.")] 
    HRESULT ShortTransferOK([in] BOOL ShortTransfer);
/*doc
\def\tfdoclabelextn{:1} % set label extension to ':1'
\begin{function}{}{ Property }{HRESULT}{ShortTransferOK}{}{
  Setting this property to TRUE allows data transfers shorter than the endpoint's FIFO size
  for the endpoint that is bound to the USBIO COM object instance.
  Setting this property to FALSE causes short transfers to fail with an error status.
  }
  \param{[in] BOOL}{ShortTransfer}{}{
  New value to be set, either TRUE or FALSE.
  }
  \comments{
  This parameter has an effect only for read operations from bulk or interrupt pipes.

  The default setting of the \temph{ShortTransferOK} property is stored in the
  registry during USBIO driver installation.
  The default value can be changed in the INF file or in the registry.
  The configuration set by means of this property is valid until the device is
  removed from the PC or the PC is booted.
  A modification during run-time does not change the default in the registry.

  This property can only be read or written after the device was opened, see \hl{OpenDevice}.
  Furthermore, the object instance must have been bound to an endpoint, see \hl{Bind}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{Bind}
  }
\end{function}
\def\tfdoclabelextn{} % set label extension to empty
\pagebreak
*/


    [propget, id(51), helpstring("Get the current FIFO size of a bound endpoint.")] 
    HRESULT EndpointFifoSize([out, retval] int *pVal);
/*doc
\begin{function}{}{ Property }{HRESULT}{EndpointFifoSize}{}{
  This read-only property returns the endpoint's FIFO size of the endpoint
  that is bound to the USBIO COM object instance.
  }
  \param{[out,retval] int*}{pVal}{}{
  A variable that receives the FIFO size, in bytes.
  }
  \comments{
  This property can only be read after the device was opened, see \hl{OpenDevice}.
  Furthermore, the object instance must have been bound to an endpoint, see \hl{Bind}.
  }
  \seealso{
  \sa{OpenDevice} \\
  \sa{Bind}
  }
\end{function}
\pagebreak
*/

    
    // PnP notifications
    [id(52), helpstring("Enable Plug and Play notification events.")]
    HRESULT EnablePnPNotification(
              [in] BSTR Guid,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{EnablePnPNotification}{}{
  This function enables Plug and Play notification events.
  }
  \param{[in] BSTR}{Guid}{}{
  A string representation of a GUID that identifies the driver interface exported by the USBIO driver.
  This can be the default USBIO GUID \{325ddf96-938c-11d3-9e34-0080c82727f4\} that is defined
  in \tital{usbio_i.h}.
  However, it is strongly recommended that a private GUID is used which has been generated by a tool
  like \tital{guidgen.exe}.
  This is important in order to differentiate between various customizations of the USBIO product.

  For the USBIO device driver the private GUID has to be defined in the setup information file \tital{usbio.inf}.
  See the USBIO Reference Manual and the \tital{usbio.inf} file for details.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  After a successful call to EnablePnPNotification the USBIO COM object will issue 
  a \hl{PnPAddNotification} event if a USB device is connected to the system and
  a \hl{PnPRemoveNotification} event if a USB device is disconnected from the system.

  If an application supports various types of devices and an individual GUID is defined for each of them
  EnablePnPNotification should be called for each GUID separately.
  This way, the application will receive Plug and Play notifications for every device it supports.
  }
  \seealso{
  \sa{DisablePnPNotification} \\
  \sa{PnPAddNotification} \\
  \sa{PnPRemoveNotification}
  }
\end{function}
\pagebreak
*/ 

    [id(53), helpstring("Disable Plug and Play notification events.")]
    HRESULT DisablePnPNotification(
              [in] BSTR Guid,
              [out] int *Status
              );
/*doc 
\begin{function}{}{ Method }{HRESULT}{DisablePnPNotification}{}{
  This function disables Plug and Play notification events.
  }
  \param{[in] BSTR}{Guid}{}{
  A string representation of a GUID that identifies the driver interface.
  This is the same GUID that was passed to \hl{EnablePnPNotification}.
  }
  \param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
  \comments{
  To disable Plug and Play notfication events this function has to be called for each 
  GUID passed to a successful call of \hl{EnablePnPNotification}.
  }
  \seealso{
  \sa{EnablePnPNotification} \\
  \sa{PnPAddNotification} \\
  \sa{PnPRemoveNotification}
  }
\end{function}
\pagebreak
*/ 


    // get bandwidth information
    [id(54), helpstring("Get information on the USB bandwidth consumption.")] 
    HRESULT GetBandwidthInfo(
              [out] int *TotalBandwidth,
              [out] int *ConsumedBandwidth,
              [out] int *Status
              );
/*doc 
\begin{function}{}{ Method }{HRESULT}{GetBandwidthInfo}{}{
  This function returns information on the current USB bandwidth consumption.
  }
\param{[out] int*}{TotalBandwidth}{}{
  A variable that will be set to the total bandwidth, in kilobits per second, available on the bus.
  This bandwidth is provided by the USB host controller the device is connected to.
  }
\param{[out] int*}{ConsumedBandwidth}{}{
  A variable that will be set to the mean bandwidth that is already in use, in kilobits per second.
  }
\param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
\comments{
  This function allows an application to check the bandwidth that is available on the USB.
  Depending on this information an application can select an appropriate 
  device configuration, if desired.

  This function can only be used after the device was opened, 
  see \hl{OpenDevice}.
  }
\seealso{
  \sa{OpenDevice}
  }
\end{function}
\pagebreak
*/ 


    // device-related information
    [propget, id(55), helpstring("TRUE if a USB 2.0 device is operating at high-speed (480 Mbit/s).")]
    HRESULT IsOperatingAtHighSpeed([out, retval] BOOL *HighSpeed);
/*doc
\begin{function}{}{ Property }{HRESULT}{IsOperatingAtHighSpeed}{}{
  This read-only property returns TRUE if the USB~2.0 device is operating at high-speed (480~Mbit/s), FALSE otherwise.
  }
\param{[out,retval] BOOL*}{HighSpeed}{}{
  A variable that will be set to TRUE or FALSE.
  }
  \comments{
  If this property returns TRUE then the USB device operates in high-speed mode.
  The USB~2.0 device is connected to a hub port that is high-speed capable.

  Note that this property does not indicate whether a device is capable of high-speed
  operation, but rather whether it is in fact operating at high-speed.

  This property can only be read after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice}
  }
\end{function}
\pagebreak
*/


    // pipe statistics
    [id(56), helpstring("Enable and configure statistical analysis for a pipe.")] 
    HRESULT SetupPipeStatistics(
              [in] int AveragingInterval,
              [out] int *Status
              );
/*doc 
\begin{function}{}{ Method }{HRESULT}{SetupPipeStatistics}{}{
  This function enables or disables a statistical analysis
  of the data transfer on a pipe.
  }
\param{[in] int}{AveragingInterval}{}{
  Specifies the time interval, in milliseconds, that is used to calculate the average 
  data rate of the pipe.
  A time averaging algorithm is used to continuously compute the mean value of the
  data transfer rate.
  The USBIO driver internally allocates memory to implement an averaging filter.
  There are 2048 bytes of memory required per second of the averaging interval.
  To limit the memory consumption the maximum supported value of 
  \temph{AveragingInterval} is 5000~milliseconds (5~seconds).
  If a longer interval is specified then the \temph{SetupPipeStatistics} function will fail.
  It is recommended to use an averaging interval of 1000~milliseconds.

  If \temph{AveragingInterval} is set to zero then the average data rate
  computation is disabled.
  This is the default state.
  An application should only enable the average data rate computation if it is needed.
  This will save resources (kernel memory and CPU cycles).
  }
\param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
\comments{
  The USBIO driver is able to analyse the data transfer (outgoing or incoming) on a pipe
  and to calculate the average data rate on that pipe.
  A time averaging algorithm is used to continuously compute the mean value of the
  data transfer rate.
  In order to save resources (kernel memory and CPU cycles) the average data rate
  computation is disabled by default.
  It has to be enabled and to be configured by means of this function 
  before it is available to an application. 
  See also the description of the \hl{QueryPipeStatistics} function 
  for more information on pipe statistics. 

  Note that the statistical data is maintained separately for each pipe or endpoint, respectively.
  The \temph{SetupPipeStatistics} function has an effect on that pipe only
  that is bound to the USBIO COM object instance.
  
  If an endpoint is unbound from the USBIO COM object instance by means of the \hl{Unbind} function
  or by deleting the instance then the average data rate computation will be disabled.
  It has to be enabled and configured when the endpoint is reused.
  In other words, if the data rate computation is needed by an application then 
  the \temph{SetupPipeStatistics} function should be called immediately after the 
  endpoint is bound by means of the \hl{Bind} function.
 
  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  Furthermore, the object instance must have been bound to an endpoint, see \hl{Bind}.
  }
\seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{Bind} \\
  \sa{Unbind} \\
  \sa{QueryPipeStatistics}
  }
\end{function}
\pagebreak
*/ 

    [id(57), helpstring("Query statistical data related to the pipe.")]
    HRESULT QueryPipeStatistics(
              [out] int *ActualAveragingInterval,
              [out] int *AverageRate,
              [out] int *BytesTransferred_L,
              [out] int *BytesTransferred_H,
              [out] int *RequestsSucceeded,
              [out] int *RequestsFailed,
              [in] int Flags,
              [out] int *Status
              );
/*doc
\begin{function}{}{ Method }{HRESULT}{QueryPipeStatistics}{}{
  This function retrieves statistical data related to the endpoint that is bound to the 
  USBIO COM object instance.
  }
\param{[out] int*}{ActualAveragingInterval}{}{
  A variable that will be set to the actual time interval, in milliseconds, that was used to calculate the average 
  data rate returned in \temph{AverageRate}.
  Normally, this value corresponds to the interval that has been configured by means
  of the \hl{SetupPipeStatistics} function.
  However, if the capacity of the internal averaging filter is not sufficient for the
  interval set then \temph{ActualAveragingInterval} can be less than the 
  averaging interval that has been configured.

  If \temph{ActualAveragingInterval} is zero then the data rate computation is disabled.
  The \temph{AverageRate} variable is always set to zero in this case.
  }
\param{[out] int*}{AverageRate}{}{
  A variable that will be set to the current average data rate of the pipe, in bytes per second.
  The average data rate will be continuously calculated if \temph{ActualAveragingInterval}
  is not null.
  If \temph{ActualAveragingInterval} is null then the data rate computation is disabled and
  \temph{AverageRate} is always set to zero.

  The computation of the average data rate has to be enabled and to be configured 
  explicitly by an application.
  This has to be done by means of the \hl{SetupPipeStatistics} function.
  }
\param{[out] int*}{BytesTransferred_L}{}{
  A variable that will be set to the lower 32~bits of the current value of the BytesTransferred counter.
  The BytesTransferred counter is an unsigned 64~bit integer.
  It counts the total number of bytes transferred on a pipe, modulo 2^64.
  }
\param{[out] int*}{BytesTransferred_H}{}{
  A variable that will be set to the upper 32~bits of the current value of the BytesTransferred counter.
  The BytesTransferred counter is an unsigned 64~bit integer.
  It counts the total number of bytes transferred on a pipe, modulo 2^64.
  }
\param{[out] int*}{RequestsSucceeded}{}{
  A variable that will be set to the current value of the RequestsSucceeded counter.
  The RequestsSucceeded counter is an unsigned 32~bit integer.
  It counts the total number of read or write requests that have been completed successfully
  on a pipe, modulo 2^32.
  
  On a bulk or interrupt endpoint the term request corresponds to a buffer that is submitted
  to perform a read or write operation.
  Thus, this counter will be incremented by one for each buffer that was successfully transferred.

  On an isochronous endpoint the term request corresponds to an isochronous data frame.
  Each buffer that is submitted to perform a read or write operation contains several isochronous data frames.
  This counter will be incremented by one for each isochronous data frame that was successfully transferred.
  }
\param{[out] int*}{RequestsFailed}{}{
  A variable that will be set to the current value of the RequestsFailed counter.
  The RequestsFailed counter is an unsigned 32~bit integer.
  It counts the total number of read or write requests that have been completed with 
  an error status on a pipe, modulo 2^32.

  On a bulk or interrupt endpoint the term request corresponds to a buffer that is submitted
  to perform a read or write operation.
  Thus, this counter will be incremented by one for each buffer that is completed with an error status.

  On an isochronous endpoint the term request corresponds to an isochronous data frame.
  Each buffer that is submitted to perform a read or write operation contains several isochronous data frames.
  This counter will be incremented by one for each isochronous data frame that is completed with an error status.
  }
\param{[in] int}{Flags}{}{
  Specifies options that modify the behaviour of the \temph{QueryPipeStatistics} function, encoded as bit flags.
  The \temph{Flags} value is set to zero or any combination (bit-wise or) of the following values.
  \begin{description1}

  \item[USBIOCOM_QPS_FLAG_RESET_BYTES_TRANSFERRED]
  If this flag is specified then the BytesTransferred counter will be reset to zero 
  after its current value has been captured and returned by this function.
  The BytesTransferred counter is an unsigned 64~bit integer.
  It counts the total number of bytes transferred on a pipe, modulo 2^64.

  \vspace{2mm}
  \item[USBIOCOM_QPS_FLAG_RESET_REQUESTS_SUCCEEDED]
  If this flag is specified then the RequestsSucceeded counter will be reset to zero 
  after its current value has been captured and returned by this function.
  The RequestsSucceeded counter is an unsigned 32~bit integer.
  It counts the total number of read or write requests that have been completed successfully
  on a pipe, modulo 2^32.

  \vspace{2mm}
  \item[USBIOCOM_QPS_FLAG_RESET_REQUESTS_FAILED]
  If this flag is specified then the RequestsFailed counter will be reset to zero 
  after its current value has been captured and returned by this function.
  The RequestsFailed counter is an unsigned 32~bit integer.
  It counts the total number of read or write requests that have been completed with 
  an error status on a pipe, modulo 2^32.

  \vspace{2mm}
  \item[USBIOCOM_QPS_FLAG_RESET_ALL_COUNTERS]
  This value combines the three flags described above.
  If \temph{USBIOCOM_QPS_FLAG_RESET_ALL_COUNTERS} is specified then all three counters 
  BytesTransferred, RequestsSucceeded, and RequestsFailed
  will be reset to zero after their current values have been captured and returned by this function.

  \end{description1}
  }
\param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
\comments{
  The USBIO device driver internally maintains some statistical data per endpoint.
  This function allows an application to query the actual values of the 
  various statistics counters.
  Optionally, individual counters can be reset to zero after queried.
  
  The USBIO device driver is also able to analyse the data transfer (outgoing or incoming) on a pipe
  and to calculate the average data rate on that pipe.
  In order to save resources (kernel memory and CPU cycles) this feature
  is disabled by default.
  It has to be enabled and to be configured by means of the \hl{SetupPipeStatistics}
  function before it is available to an application.
  Thus, before an application starts to (periodically) query the value of
  \temph{AverageRate} it has to enable the continuous computation of this value by a call to 
  \hl{SetupPipeStatistics}.
  The other statistical counters returned by this function
  will be updated by default and do not need to be enabled explicitly.

  Note that the statistical data is maintained separately for each pipe or endpoint, respectively.
  The \temph{QueryPipeStatistics} function retrieves the actual statistics of that pipe
  that is bound to the USBIO COM object instance.

  This function can only be used after the device was opened and configured, 
  see \hl{OpenDevice} and \hl{SetConfiguration}.
  Furthermore, the object instance must have been bound to an endpoint, see \hl{Bind}.
  }
\seealso{
  \sa{OpenDevice} \\
  \sa{SetConfiguration} \\
  \sa{Bind} \\
  \sa{SetupPipeStatistics} \\
  \sa{USBIOCOM_QUERY_PIPE_STATISTICS_FLAGS}
  }
\end{function}
\pagebreak
*/ 

    [id(58), helpstring("Acquires the device for exclusive use.")]
    HRESULT AcquireDevice(
              [out] int *Status
              );
/*doc 
\begin{function}{}{ Method }{HRESULT}{AcquireDevice}{}{
  This function acquires a device for exclusive use.
  }
\param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
\comments{
  If this function returns with success no other process can open this device. The same process 
  can open additional handles to the device.

  The operation fails with USBIO_ERR_DEVICE_OPENED if the device is opened 
  by a different process.

  This function can only be used after the device was opened, 
  see \hl{OpenDevice}.
  }
\seealso{
  \sa{OpenDevice}
  }
\end{function}
\pagebreak
*/ 
    [id(59), helpstring("Release the exclusive use for this device.")]
    HRESULT ReleaseDevice(
              [out] int *Status
              );
/*doc 
\begin{function}{}{ Method }{HRESULT}{ReleaseDevice}{}{
  This function releases the exclusive use of a device. 
  }
\param{[out] int*}{Status}{}{
  A variable that receives the completion status of the operation.
  The returned value is zero in case of success, or an error code otherwise.
  Error codes are listed in section~\ref{sec_errorcodes}.
  }
\comments{
  If this function returns with success other processes can open the device.
  The device is also released if the last handle of a process is closed.


  This function can only be used after the device was opened, 
  see \hl{OpenDevice}.
  }
\seealso{
  \sa{CloseDevice}
  }
\end{function}
\pagebreak
*/ 

   // device-related information
    [propget, id(60), helpstring("Returns the count of all open handles to the device.")]
    HRESULT OpenCount([out, retval] int *OpenCountValue);
/*doc
\begin{function}{}{ Property }{HRESULT}{OpenCount}{}{
  This read-only property returns the number of all open handles to this device.
  }
\param{[out,retval] int*}{OpenCountValue}{}{
  A variable that returns the count of open handles.
  }
  \comments{
  This property returns the number of all open handles. This includes handles that are opened 
  by other applications and the handle with is used to make the function call.

  If the property returns 0 the device is not opened.

  This property can only be read after the device was opened, see \hl{OpenDevice}.
  }
  \seealso{
  \sa{OpenDevice}
  }
\end{function}
\pagebreak
*/

			    
}; // end interface IUSBIOInterface3
/*doc
%% \end{class}
*/


//*************** USBIOCOM Type Library **********************
[
  uuid(F95AB400-6BA5-44dd-BF19-AAB5AD44CD65),
  version(3.0),
  helpstring("USBIOCOM 3.0 Type Library")
]
library USBIOCOMLib
{
  importlib("stdole32.tlb");
  importlib("stdole2.tlb");


/*doc errcodes
*/
[ helpstring("USBIOCOM_ERR_CODES") ]
typedef [v1_enum] enum _USBIOCOM_ERR_CODES {
    // codes defined in usbio_i.h
/*doc
    USBIO_ERR_SUCCESS                  & 0x00000000L \\\hline
*/
    USBIO_ERR_SUCCESS                  = 0x00000000L,
   
    USBIO_ERR_CRC                      = 0xE0000001L,
    USBIO_ERR_BTSTUFF                  = 0xE0000002L,
    USBIO_ERR_DATA_TOGGLE_MISMATCH     = 0xE0000003L,
    USBIO_ERR_STALL_PID                = 0xE0000004L,
    USBIO_ERR_DEV_NOT_RESPONDING       = 0xE0000005L,
    USBIO_ERR_PID_CHECK_FAILURE        = 0xE0000006L,
    USBIO_ERR_UNEXPECTED_PID           = 0xE0000007L,
    USBIO_ERR_DATA_OVERRUN             = 0xE0000008L,
    USBIO_ERR_DATA_UNDERRUN            = 0xE0000009L,
    USBIO_ERR_RESERVED1                = 0xE000000AL,
    USBIO_ERR_RESERVED2                = 0xE000000BL,
    USBIO_ERR_BUFFER_OVERRUN           = 0xE000000CL,
    USBIO_ERR_BUFFER_UNDERRUN          = 0xE000000DL,
    USBIO_ERR_NOT_ACCESSED             = 0xE000000FL,
    USBIO_ERR_FIFO                     = 0xE0000010L,
    USBIO_ERR_XACT_ERROR               = 0xE0000011L,
    USBIO_ERR_BABBLE_DETECTED          = 0xE0000012L,
    USBIO_ERR_DATA_BUFFER_ERROR        = 0xE0000013L,
    USBIO_ERR_ENDPOINT_HALTED          = 0xE0000030L,

    USBIO_ERR_NO_MEMORY                = 0xE0000100L,
    USBIO_ERR_INVALID_URB_FUNCTION     = 0xE0000200L,
    USBIO_ERR_INVALID_PARAMETER        = 0xE0000300L,
    USBIO_ERR_ERROR_BUSY               = 0xE0000400L,
    USBIO_ERR_REQUEST_FAILED           = 0xE0000500L,
    USBIO_ERR_INVALID_PIPE_HANDLE      = 0xE0000600L,
    USBIO_ERR_NO_BANDWIDTH             = 0xE0000700L,
    USBIO_ERR_INTERNAL_HC_ERROR        = 0xE0000800L,
    USBIO_ERR_ERROR_SHORT_TRANSFER     = 0xE0000900L,
    USBIO_ERR_BAD_START_FRAME          = 0xE0000A00L,
    USBIO_ERR_ISOCH_REQUEST_FAILED     = 0xE0000B00L,
    USBIO_ERR_FRAME_CONTROL_OWNED      = 0xE0000C00L,
    USBIO_ERR_FRAME_CONTROL_NOT_OWNED  = 0xE0000D00L,
    USBIO_ERR_NOT_SUPPORTED            = 0xE0000E00L,
    USBIO_ERR_INVALID_CONFIGURATION_DESCRIPTOR = 0xE0000F00L,

    USBIO_ERR_INSUFFICIENT_RESOURCES   = 0xE8001000L,
    USBIO_ERR_SET_CONFIG_FAILED        = 0xE0002000L,
    USBIO_ERR_USBD_BUFFER_TOO_SMALL    = 0xE0003000L,
    USBIO_ERR_USBD_INTERFACE_NOT_FOUND = 0xE0004000L,
    USBIO_ERR_INVALID_PIPE_FLAGS       = 0xE0005000L,
    USBIO_ERR_USBD_TIMEOUT             = 0xE0006000L,
    USBIO_ERR_DEVICE_GONE              = 0xE0007000L,
    USBIO_ERR_STATUS_NOT_MAPPED        = 0xE0008000L,

    USBIO_ERR_CANCELED                 = 0xE0010000L,
    USBIO_ERR_ISO_NOT_ACCESSED_BY_HW   = 0xE0020000L,
    USBIO_ERR_ISO_TD_ERROR             = 0xE0030000L,
    USBIO_ERR_ISO_NA_LATE_USBPORT      = 0xE0040000L,
    USBIO_ERR_ISO_NOT_ACCESSED_LATE    = 0xE0050000L,

    USBIO_ERR_FAILED                   = 0xE0001000L,
    USBIO_ERR_INVALID_INBUFFER         = 0xE0001001L,
    USBIO_ERR_INVALID_OUTBUFFER        = 0xE0001002L,
    USBIO_ERR_OUT_OF_MEMORY            = 0xE0001003L,
    USBIO_ERR_PENDING_REQUESTS         = 0xE0001004L,
    USBIO_ERR_ALREADY_CONFIGURED       = 0xE0001005L,
    USBIO_ERR_NOT_CONFIGURED           = 0xE0001006L,
    USBIO_ERR_OPEN_PIPES               = 0xE0001007L,
    USBIO_ERR_ALREADY_BOUND            = 0xE0001008L,
    USBIO_ERR_NOT_BOUND                = 0xE0001009L,
    USBIO_ERR_DEVICE_NOT_PRESENT       = 0xE000100AL,
    USBIO_ERR_CONTROL_NOT_SUPPORTED    = 0xE000100BL,
    USBIO_ERR_TIMEOUT                  = 0xE000100CL,
    USBIO_ERR_INVALID_RECIPIENT        = 0xE000100DL,
    USBIO_ERR_INVALID_TYPE             = 0xE000100EL,
    USBIO_ERR_INVALID_IOCTL            = 0xE000100FL,
    USBIO_ERR_INVALID_DIRECTION        = 0xE0001010L,
    USBIO_ERR_TOO_MUCH_ISO_PACKETS     = 0xE0001011L,
    USBIO_ERR_POOL_EMPTY               = 0xE0001012L,
    USBIO_ERR_PIPE_NOT_FOUND           = 0xE0001013L,
    USBIO_ERR_INVALID_ISO_PACKET       = 0xE0001014L,
    USBIO_ERR_OUT_OF_ADDRESS_SPACE     = 0xE0001015L,
    USBIO_ERR_INTERFACE_NOT_FOUND      = 0xE0001016L,
    USBIO_ERR_INVALID_DEVICE_STATE     = 0xE0001017L,
    USBIO_ERR_INVALID_PARAM            = 0xE0001018L,
    USBIO_ERR_DEMO_EXPIRED             = 0xE0001019L,
    USBIO_ERR_INVALID_POWER_STATE      = 0xE000101AL,
    USBIO_ERR_POWER_DOWN               = 0xE000101BL,
    USBIO_ERR_VERSION_MISMATCH         = 0xE000101CL,
    USBIO_ERR_SET_CONFIGURATION_FAILED = 0xE000101DL,
	USBIO_ERR_ADDITIONAL_EVENT_SIGNALLED = 0xE000101EL,
	USBIO_ERR_INVALID_PROCESS          = 0xE000101FL,
	USBIO_ERR_DEVICE_ACQUIRED          = 0xE0001020L,
	USBIO_ERR_DEVICE_OPENED            = 0xE0001021L,

    USBIO_ERR_VID_RESTRICTION          = 0xE0001080L,
    USBIO_ERR_ISO_RESTRICTION          = 0xE0001081L,
    USBIO_ERR_BULK_RESTRICTION         = 0xE0001082L,
    USBIO_ERR_EP0_RESTRICTION          = 0xE0001083L,
    USBIO_ERR_PIPE_RESTRICTION         = 0xE0001084L,
    USBIO_ERR_PIPE_SIZE_RESTRICTION    = 0xE0001085L,
    USBIO_ERR_CONTROL_RESTRICTION      = 0xE0001086L,
    USBIO_ERR_INTERRUPT_RESTRICTION    = 0xE0001087L,

    USBIO_ERR_DEVICE_NOT_FOUND         = 0xE0001100L,
    USBIO_ERR_DEVICE_NOT_OPEN          = 0xE0001102L,
    USBIO_ERR_NO_SUCH_DEVICE_INSTANCE  = 0xE0001104L,
    USBIO_ERR_INVALID_FUNCTION_PARAM   = 0xE0001105L,
    USBIO_ERR_LOAD_SETUP_API_FAILED    = 0xE0001106L,
	USBIO_ERR_DEVICE_ALREADY_OPENED    = 0xE0001107L,



    // codes defined by the COM object
/*doc
    USBIO_ERR_NOT_ENUMERATED           & 0xE000A001L \\\hline
*/
    USBIO_ERR_NOT_ENUMERATED           = 0xE000A001L,
/*doc 
    USBIO_ERR_TOO_MANY_INTERFACES      & 0xE000A002L \\\hline
*/
    USBIO_ERR_TOO_MANY_INTERFACES      = 0xE000A002L,
/*doc 
    USBIO_ERR_NO_INTERFACE             & 0xE000A003L \\\hline
*/
    USBIO_ERR_NO_INTERFACE             = 0xE000A003L,
/*doc 
    USBIO_ERR_START_THREAD_FAILED      & 0xE000A004L \\\hline
*/
    USBIO_ERR_START_THREAD_FAILED      = 0xE000A004L,
/*doc 
    USBIO_ERR_NO_DATA                  & 0xE000A005L \\\hline
*/
    USBIO_ERR_NO_DATA                  = 0xE000A005L,
/*doc 
    USBIO_ERR_BUFFER_TOO_SMALL         & 0xE000A006L \\\hline
*/
    USBIO_ERR_BUFFER_TOO_SMALL         = 0xE000A006L,
/*doc 
    USBIO_ERR_THREAD_IS_RUNNING        & 0xE000A007L \\\hline
*/
    USBIO_ERR_THREAD_IS_RUNNING        = 0xE000A007L,
/*doc 
    USBIO_ERR_INVALID_PIPE_TYPE        & 0xE000A008L \\\hline
*/
    USBIO_ERR_INVALID_PIPE_TYPE        = 0xE000A008L,
/*doc 
    USBIO_ERR_NO_BUFFER                & 0xE000A009L \\\hline
*/
    USBIO_ERR_NO_BUFFER                = 0xE000A009L,
/*doc 
    USBIO_ERR_BUFFER_TOO_LARGE         & 0xE000A00AL \\\hline
*/
    USBIO_ERR_BUFFER_TOO_LARGE         = 0xE000A00AL,
/*doc 
    USBIO_ERR_WRITE_NOT_STARTED        & 0xE000A00BL \\\hline 
*/
    USBIO_ERR_WRITE_NOT_STARTED        = 0xE000A00BL, 
/*doc 
    USBIO_ERR_READ_NOT_STARTED         & 0xE000A00CL \\\hline
*/
    USBIO_ERR_READ_NOT_STARTED         = 0xE000A00CL,
/*doc 
    USBIO_ERR_INVALID_ISO_BUFFER       & 0xE000A00DL \\\hline
*/
    USBIO_ERR_INVALID_ISO_BUFFER       = 0xE000A00DL,
/*doc 
    USBIO_ERR_STATUS_ARRAY_TOO_SMALL   & 0xE000A00EL \\\hline
*/
    USBIO_ERR_STATUS_ARRAY_TOO_SMALL   = 0xE000A00EL,
/*doc 
    USBIO_ERR_INVALID_ARRAY            & 0xE000A00FL \\\hline
*/
    USBIO_ERR_INVALID_ARRAY            = 0xE000A00FL,
/*doc 
    USBIO_ERR_DEVICE_ALREADY_OPEN      & 0xE000A010L \\\hline
*/
    USBIO_ERR_DEVICE_ALREADY_OPEN      = 0xE000A010L,
/*doc 
    USBIO_ERR_ALREADY_CALLED           & 0xE000A011L \\\hline
*/
    USBIO_ERR_ALREADY_CALLED           = 0xE000A011L
  
} USBIOCOM_ERR_CODES;



/*doc enum
*/

[ helpstring("USBIOCOM_INFO_FLAGS") ]
typedef [v1_enum] enum _USBIOCOM_INFO_FLAGS {

  USBIOCOM_INFOFLAG_CHECKED_BUILD   = 0x00000010,
  USBIOCOM_INFOFLAG_DEMO_VERSION    = 0x00000020,
  USBIOCOM_INFOFLAG_LIGHT_VERSION   = 0x00000100

} USBIOCOM_INFO_FLAGS;
/*doc
\begin{enumtype}{}{}{}{USBIOCOM_INFO_FLAGS}{}{
  This enumeration defines constants that provide information on the USBIO device driver that is currently running.
  }
  \entry{USBIOCOM_INFOFLAG_CHECKED_BUILD}{ = 0x00000010}{
  If this flag is set the driver that is currently running is a checked (debug) build.
  }
  \entry{USBIOCOM_INFOFLAG_DEMO_VERSION}{ = 0x00000020}{
  If this flag is set the driver that is currently running is a DEMO version that has some restrictions.
  Refer to \tital{ReadMe.txt} for a description of the restrictions.
  }
  \entry{USBIOCOM_INFOFLAG_LIGHT_VERSION}{ = 0x00000100}{
  If this flag is set the driver that is currently running is a LIGHT version that has some restrictions.
  Refer to \tital{ReadMe.txt} for a description of the restrictions.
  }
  \comments{
  The values defined by \temph{USBIOCOM_INFO_FLAGS} are used in conjunction with the 
  \hl{GetDriverInfo} method.
  }
  \seealso{
  \sa{GetDriverInfo}
  }
\end{enumtype}
\pagebreak
*/


[ helpstring("USBIOCOM_DEVICE_OPTION_FLAGS") ]
typedef [v1_enum] enum _USBIOCOM_DEVICE_OPTION_FLAGS {

  USBIOCOM_RESET_DEVICE_ON_CLOSE = 0x00000001,
  USBIOCOM_UNCONFIGURE_ON_CLOSE  = 0x00000002,
  USBIOCOM_ENABLE_REMOTE_WAKEUP  = 0x00000004

} USBIOCOM_DEVICE_OPTION_FLAGS;
/*doc
\begin{enumtype}{}{}{}{USBIOCOM_DEVICE_OPTION_FLAGS}{}{
  This enumeration defines constants used to customize the behavior of the USBIO device driver.
  }
  \entry{USBIOCOM_RESET_DEVICE_ON_CLOSE}{ = 0x00000001}{
    If this option is set a USB device reset is sent to the device after the last USBIO COM object instance
    has closed the device by a call to \hl{CloseDevice}.
  }
  \entry{USBIOCOM_UNCONFIGURE_ON_CLOSE}{ = 0x00000002}{
    If this option is set the USB device will be unconfigured after the last USBIO COM object instance
    has closed the device by a call to \hl{CloseDevice}.
  }
  \entry{USBIOCOM_ENABLE_REMOTE_WAKEUP}{ = 0x00000004}{
    If this option is set the remote wake-up feature is enabled for the device.
    At least one USBIO COM object instance must be open for the device to allow
    the remote wake-up event to occur.
  }
  \comments{
  The values defined by \temph{USBIOCOM_DEVICE_OPTION_FLAGS} are used in conjunction with the 
  \hl{DeviceOptions} property.
  }
  \seealso{
  \sa{DeviceOptions} \\
  \sa{OpenDevice} \\
  \sa{CloseDevice}
  }
\end{enumtype}
\pagebreak
*/


[ helpstring("USBIOCOM_PIPE_OPTION_FLAGS") ]
typedef [v1_enum] enum _USBIOCOM_PIPE_OPTION_FLAGS {

  USBIOCOM_SHORT_TRANSFER_OK    = 0x00010000

} USBIOCOM_PIPE_OPTION_FLAGS;
/*doc
\begin{enumtype}{}{}{}{USBIOCOM_PIPE_OPTION_FLAGS}{}{
  This enumeration defines constants used to define the behavior of data transfers.
  }
  \entry{USBIOCOM_SHORT_TRANSFER_OK}{ = 0x00010000}{
    If this flag is set, the USBIO driver does not return an error if a data
    packet received from the device is shorter than the maximum packet size
    of the endpoint. Otherwise, a short packet causes an error condition.
  }
  \comments{
  The values defined by \temph{USBIOCOM_PIPE_OPTION_FLAGS} are used with various functions, 
  see \hl{ClassOrVendorInRequest}.
  }
  \seealso{
  \sa{ClassOrVendorInRequest}
  }
\end{enumtype}
\pagebreak
*/


[ helpstring("USBIOCOM_REQUEST_RECIPIENT") ]
typedef [v1_enum] enum _USBIOCOM_REQUEST_RECIPIENT {

  USBIOCOM_RecipientDevice      = 0,
  USBIOCOM_RecipientInterface   = 1,
  USBIOCOM_RecipientEndpoint    = 2,
  USBIOCOM_RecipientOther       = 3     

} USBIOCOM_REQUEST_RECIPIENT;
/*doc
\begin{enumtype}{}{}{}{USBIOCOM_REQUEST_RECIPIENT}{}{
  This enumeration defines constants that identify the recipient of a USB device request.
  }
  \entry{USBIOCOM_RecipientDevice}{ = 0}{}
  \entry{USBIOCOM_RecipientInterface}{ = 1}{}
  \entry{USBIOCOM_RecipientEndpoint}{ = 2}{}
  \entry{USBIOCOM_RecipientOther}{ = 3}{}
  \comments{
  The meaning of the values is defined by the Universal Serial Bus Specification, Chapter~9. 
  }
  \seealso{
  \sa{GetDescriptor} \\
  \sa{SetDescriptor} \\
  \sa{ClassOrVendorInRequest} \\
  \sa{ClassOrVendorOutRequest} \\
  \sa{SetFeature} \\
  \sa{ClearFeature} \\
  \sa{GetStatus}
  }
\end{enumtype}
\pagebreak
*/


[ helpstring("USBIOCOM_REQUEST_TYPE") ]
typedef [v1_enum] enum _USBIOCOM_REQUEST_TYPE {

  USBIOCOM_RequestTypeClass   = 1,
  USBIOCOM_RequestTypeVendor  = 2

} USBIOCOM_REQUEST_TYPE;
/*doc
\begin{enumtype}{}{}{}{USBIOCOM_REQUEST_TYPE}{}{
  This enumeration defines constants that identify the type of a USB device request.
  }
  \entry{USBIOCOM_RequestTypeClass}{ = 1}{}
  \entry{USBIOCOM_RequestTypeVendor}{ = 2}{}
  \comments{
  The meaning of the values is defined by the Universal Serial Bus Specification, Chapter~9. 

  Note that the enumeration does not contain the Standard request type defined by the USB specification.
  This is because the explicit generation of Standard requests is not supported by the USBD interface
  and by the USBIO driver, respectively.
  USB Standard requests are generated implicitely on various functions.
  }
  \seealso{
  \sa{ClassOrVendorInRequest} \\
  \sa{ClassOrVendorOutRequest}
  }
\end{enumtype}
\pagebreak
*/


[ helpstring("USBIOCOM_PIPE_TYPE") ]
typedef [v1_enum] enum _USBIOCOM_PIPE_TYPE {

  USBIOCOM_PipeTypeControl      = 0,
  USBIOCOM_PipeTypeIsochronous  = 1,
  USBIOCOM_PipeTypeBulk         = 2,
  USBIOCOM_PipeTypeInterrupt    = 3

} USBIOCOM_PIPE_TYPE;
/*doc
\begin{enumtype}{}{}{}{USBIOCOM_PIPE_TYPE}{}{
  This enumeration defines constants that identify the type of a USB pipe, or a USB endpoint, respectively.
  }
  \entry{USBIOCOM_PipeTypeControl}{ = 0}{}
  \entry{USBIOCOM_PipeTypeIsochronous}{ = 1}{}
  \entry{USBIOCOM_PipeTypeBulk}{ = 2}{}
  \entry{USBIOCOM_PipeTypeInterrupt}{ = 3}{}
  \comments{
  The meaning of the values is defined by the Universal Serial Bus Specification, Chapter~9. 
  }
\end{enumtype}
\pagebreak
*/


[ helpstring("USBIOCOM_DEVICE_POWER_STATE, D0 - on, D1,D2 - suspend, D3 - off") ]
typedef [v1_enum] enum _USBIOCOM_DEVICE_POWER_STATE {

  USBIOCOM_DevicePowerStateD0 = 0,
  USBIOCOM_DevicePowerStateD1 = 1,
  USBIOCOM_DevicePowerStateD2 = 2,
  USBIOCOM_DevicePowerStateD3 = 3

} USBIOCOM_DEVICE_POWER_STATE;
/*doc
\begin{enumtype}{}{}{}{USBIOCOM_DEVICE_POWER_STATE}{}{
  This enumeration defines constants that describe the power state of a USB device.
  }
  \entry{USBIOCOM_DevicePowerStateD0}{ = 0}{
    Device fully on, normal operation.
  }
  \entry{USBIOCOM_DevicePowerStateD1}{ = 1}{
    Device in suspend state.
  }
  \entry{USBIOCOM_DevicePowerStateD2}{ = 2}{
    Device in suspend state.
  }
  \entry{USBIOCOM_DevicePowerStateD3}{ = 3}{
    Device off.
  }
  \comments{
  The meaning of the values is defined by the Power Management specification.

  The values defined by \temph{USBIOCOM_DEVICE_POWER_STATE} are used with the functions
  \hl{GetDevicePowerState} and \hl{SetDevicePowerState}.
  }
  \seealso{
  \sa{GetDevicePowerState} \\
  \sa{SetDevicePowerState}
  }
\end{enumtype}
\pagebreak
*/


[ helpstring("USBIOCOM_DESCRIPTOR_TYPE") ]
typedef [v1_enum] enum _USBIOCOM_DESCRIPTOR_TYPE {

  USB_DeviceDescriptorType                = 0x01,
  USB_ConfigurationDescriptorType         = 0x02,
  USB_StringDescriptorType                = 0x03,
  USB_InterfaceDescriptorType             = 0x04,
  USB_EndpointDescriptorType              = 0x05,
  USB_HID_DescriptorType                  = 0x21

} USBIOCOM_DESCRIPTOR_TYPE;
/*doc
\begin{enumtype}{}{}{}{USBIOCOM_DESCRIPTOR_TYPE}{} {
  This enumeration defines constants that identify the type of a USB descriptor.
  }
  \entry{USB_DeviceDescriptorType}{ = 0x01}{
    USB device descriptor.
  }
  \entry{USB_ConfigurationDescriptorType}{ = 0x02}{
    USB configuration descriptor, which contains further configuration, interface, endpoint, and class specific descriptors.
  }
  \entry{USB_StringDescriptorType}{ = 0x03}{
    USB string descriptor.
  }
  \entry{USB_InterfaceDescriptorType}{ = 0x04}{
    USB interface descriptor.
  }
  \entry{USB_EndpointDescriptorType}{ = 0x05}{
    USB endpoint descriptor.
  }
  \entry{USB_HID_DescriptorType}{ = 0x21}{
    USB HID descriptor. 
    This is a class-specific descriptor.
    Note that the code 0x21 is also used by other classes.
  }
  \comments{
  The values are defined by the Universal Serial Bus Specification, Chapter~9. 
  }
  \seealso{
  \sa{GetDescriptor} \\
  \sa{SetDescriptor}
  }
\end{enumtype}
\pagebreak
*/

[ helpstring("USBIOCOM_QUERY_PIPE_STATISTICS") ]
typedef [v1_enum] enum _USBIOCOM_QUERY_PIPE_STATISTICS_FLAGS {

  USBIOCOM_QPS_FLAG_RESET_BYTES_TRANSFERRED   = 0x00000001,
  USBIOCOM_QPS_FLAG_RESET_REQUESTS_SUCCEEDED  = 0x00000002,
  USBIOCOM_QPS_FLAG_RESET_REQUESTS_FAILED     = 0x00000004,
  USBIOCOM_QPS_FLAG_RESET_ALL_COUNTERS        = 0x00000007

} USBIOCOM_QUERY_PIPE_STATISTICS_FLAGS;
/*doc
\begin{enumtype}{}{}{}{USBIOCOM_QUERY_PIPE_STATISTICS_FLAGS}{} {
  This enumeration defines constants that are intended for modifying the behaviour of 
  the \temph{QueryPipeStatistics} function.
  }
\entry{USBIOCOM_QPS_FLAG_RESET_BYTES_TRANSFERRED}{ = 0x00000001}{
  Reset the BytesTransferred counter to zero after its current value has been captured and returned.
  }
\entry{USBIOCOM_QPS_FLAG_RESET_REQUESTS_SUCCEEDED}{ = 0x00000002}{
  Reset the RequestsSucceeded counter to zero after its current value has been captured and returned.
  }
\entry{USBIOCOM_QPS_FLAG_RESET_REQUESTS_FAILED}{ = 0x00000004}{
  Reset the RequestsFailed counter to zero after its current value has been captured and returned.
  }
\entry{USBIOCOM_QPS_FLAG_RESET_ALL_COUNTERS}{ = 0x00000007}{
  Reset all three counters BytesTransferred, RequestsSucceeded, and RequestsFailed to zero after 
  their current values have been captured and returned.
  This value combines the three flags described above.
  }
\comments{
  The values defined by \temph{USBIOCOM_QUERY_PIPE_STATISTICS_FLAGS} are used in conjunction with the 
  \hl{QueryPipeStatistics} method.
  }
\seealso{
  \sa{QueryPipeStatistics}
  }
\end{enumtype}
\pagebreak
*/



//*************** _IUSBIOInterfaceEvents Interface **********************
  [
    uuid(3C83A43F-CFD4-4781-8949-04EDDBD3E191),
    helpstring("_IUSBIOInterfaceEvents3 Interface")
  ]
  dispinterface _IUSBIOInterfaceEvents3
  {
/*doc Event
%% \begin{class}{}{ Interface}{_IUSBIOInterfaceEvents}{
%%  The \temph{_IUSBIOInterfaceEvents} interface provides the event call-back functions required
%%  to handle events issued by the USBIO COM object.
%%  }
*/
    properties:
    
    methods:

    [id(1), helpstring("The ReadComplete event is issued when data is available for reading by the application.")] 
    HRESULT ReadComplete(IDispatch *Obj);
/*doc
\begin{function}{}{ Method }{HRESULT}{ReadComplete}{}{
  This function is called when the \temph{ReadComplete} event is issued by the USBIO COM object instance.
  }
  \param{IDispatch*}{Obj}{}{
  Pointer to the USBIO COM object instance.
  }
  \comments{
  The \temph{ReadComplete} event is issued when data is available for reading by the application.
  }
  \seealso{
  \sa{StartReading} \\
  \sa{ReadData} \\
  \sa{ReadIsoData}
  }
\end{function}
\pagebreak
*/    

    [id(2), helpstring("The WriteComplete event is issued when buffer space is available. The application can write more data.")] 
    HRESULT WriteComplete(IDispatch *Obj);
/*doc
\begin{function}{}{ Method }{HRESULT}{WriteComplete}{}{
  This function is called when the \temph{WriteComplete} event is issued by the USBIO COM object instance.
  }
  \param{IDispatch*}{Obj}{}{
  Pointer to the USBIO COM object instance.
  }
  \comments{
  The \temph{WriteComplete} event is issued when buffer space is available.
  The application can write more data.
  }
  \seealso{
  \sa{StartWriting} \\
  \sa{WriteData} \\
  \sa{WriteIsoData} \\
  \sa{GetWriteStatus} \\
  \sa{GetIsoWriteStatus} \\
  \sa{WriteStatusAvailable}
  }
\end{function}
\pagebreak
*/    

    [id(3), helpstring("The WriteStatusAvailable event is issued when a write operation was completed. The completion status of the operation can be retrieved.")] 
    HRESULT WriteStatusAvailable(IDispatch *Obj);
/*doc
\begin{function}{}{ Method }{HRESULT}{WriteStatusAvailable}{}{
  This function is called when the \temph{WriteStatusAvailable} event is issued by the USBIO COM object instance.
  }
  \param{IDispatch*}{Obj}{}{
  Pointer to the USBIO COM object instance.
  }
  \comments{
  The \temph{WriteStatusAvailable} event is issued when a write operation was completed.
  The completion status of the operation can be retrieved.
  }
  \seealso{
  \sa{StartWriting} \\
  \sa{WriteData} \\
  \sa{WriteIsoData} \\
  \sa{GetWriteStatus} \\
  \sa{GetIsoWriteStatus} \\
  \sa{WriteComplete}
  }
\end{function}
\pagebreak
*/    

    [id(4), helpstring("The PnPAddNotification event is issued when a USB device is connected to the host.")] 
    HRESULT PnPAddNotification(IDispatch *Obj);
/*doc
\begin{function}{}{ Method }{HRESULT}{PnPAddNotification}{}{
  This function is called when the \temph{PnPAddNotification} event is issued by the USBIO COM object instance.
  }
  \param{IDispatch*}{Obj}{}{
  Pointer to the USBIO COM object instance.
  }
  \comments{
  The \temph{PnPAddNotification} event is issued when a USB device is connected to the host.
  A device enumeration should be performed by the application, see \hl{EnumerateDevices}.
  }
  \seealso{
  \sa{EnablePnPNotification} \\
  \sa{DisablePnPNotification} \\
  \sa{EnumerateDevices} \\
  \sa{OpenDevice} \\
  \sa{PnPRemoveNotification}
  }
\end{function}
\pagebreak
*/    

    [id(5), helpstring("The PnPRemoveNotification event is issued when a USB device is disconnected from the host.")] 
    HRESULT PnPRemoveNotification(IDispatch *Obj);
/*doc
\begin{function}{}{ Method }{HRESULT}{PnPRemoveNotification}{}{
  This function is called when the \temph{PnPRemoveNotification} event is issued by the USBIO COM object instance.
  }
  \param{IDispatch*}{Obj}{}{
  Pointer to the USBIO COM object instance.
  }
  \comments{
  The \temph{PnPRemoveNotification} event is issued when a USB device is disconnected from the host.

  In order to determine the device instance which has been removed the application can send a standard request,
  for example \hl{GetDeviceDescriptor}, to each active device instance.
  If the request succeeds the device is still present.
  If the request fails with an error code of \temph{USBIO_ERR_DEVICE_NOT_PRESENT} the device has been removed.

  An application should close all USBIO COM object instances open for a USB device that has been removed.
  This will free all associated resources.
  }
  \seealso{
  \sa{EnablePnPNotification} \\
  \sa{DisablePnPNotification} \\
  \sa{CloseDevice} \\
  \sa{EnumerateDevices} \\
  \sa{PnPAddNotification}
  }
\end{function}
\pagebreak
*/    

  }; //end dispinterface _IUSBIOInterfaceEvents3
/*doc
%% \end{class}
*/



//*************** USBIOInterface3 Class **********************
  [
    uuid(B949A098-6A08-4eee-B32D-CA0D19BBF24E),
    helpstring("USBIOInterface3 Class")
  ]
  coclass USBIOInterface3
  {
    [default] interface IUSBIOInterface3;
    [default, source] dispinterface _IUSBIOInterfaceEvents3;
  };

}; //end library USBIOCOMLib

/****************************** EOF ****************************************/
