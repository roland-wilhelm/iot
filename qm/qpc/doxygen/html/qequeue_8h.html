<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C: qequeue.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>qequeue.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>platform-independent event queue interface.  
<a href="#_details">More...</a></p>

<p><a href="qequeue_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_e_queue.html">QEQueue</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Native QF Event Queue.  <a href="struct_q_e_queue.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qequeue_8h.html#a54463011114f6b076e0bd62e3fa27102">QF_EQUEUE_CTR_SIZE</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The size (in bytes) of the ring-buffer counters used in the native QF event queue implementation. Valid values: 1, 2, or 4; default 1.  <a href="#a54463011114f6b076e0bd62e3fa27102"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qequeue_8h.html#a1559cc07b69d811deb906f65f376b9d8">QEQueue_getNFree</a>(me_)&#160;&#160;&#160;((me_)-&gt;nFree)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"raw" thread-safe QF event queue operation for obtaining the number of free entries still available in the queue.  <a href="#a1559cc07b69d811deb906f65f376b9d8"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qequeue_8h.html#abec6b357b489b637afc622b6ee635921">QEQueue_init</a> (<a class="el" href="struct_q_e_queue.html">QEQueue</a> *me, <a class="el" href="struct_q_event.html">QEvent</a> const *qSto[], QEQueueCtr qLen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the native QF event queue.  <a href="#abec6b357b489b637afc622b6ee635921"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qequeue_8h.html#a1432f9632a6f30c434aea96cc20aa2cf">QEQueue_postFIFO</a> (<a class="el" href="struct_q_e_queue.html">QEQueue</a> *me, <a class="el" href="struct_q_event.html">QEvent</a> const *e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"raw" thread-safe QF event queue implementation for the First-In-First-Out (FIFO) event posting. You can call this function from any task context or ISR context. Please note that this function uses internally a critical section.  <a href="#a1432f9632a6f30c434aea96cc20aa2cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qequeue_8h.html#a8ea2e15922ce2e213aa0c27e72cd730a">QEQueue_postLIFO</a> (<a class="el" href="struct_q_e_queue.html">QEQueue</a> *me, <a class="el" href="struct_q_event.html">QEvent</a> const *e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"raw" thread-safe QF event queue implementation for the Last-In-First-Out (LIFO) event posting.  <a href="#a8ea2e15922ce2e213aa0c27e72cd730a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qequeue_8h.html#ae5d5b1feb038085e2922e2f4e45b48a0">QEQueue_get</a> (<a class="el" href="struct_q_e_queue.html">QEQueue</a> *me)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"raw" thread-safe QF event queue implementation for the event get operation.  <a href="#ae5d5b1feb038085e2922e2f4e45b48a0"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>platform-independent event queue interface. </p>
<p>This header file must be included in all QF ports that use native QF event queue implementation. Also, this file is needed when the "raw" thread-safe queues are used for communication between active objects and non-framework entities, such as ISRs, device drivers, or legacy code. </p>

<p>Definition in file <a class="el" href="qequeue_8h_source.html">qequeue.h</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a1559cc07b69d811deb906f65f376b9d8"></a><!-- doxytag: member="qequeue.h::QEQueue_getNFree" ref="a1559cc07b69d811deb906f65f376b9d8" args="(me_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QEQueue_getNFree</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_</td><td>)</td>
          <td>&#160;&#160;&#160;((me_)-&gt;nFree)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"raw" thread-safe QF event queue operation for obtaining the number of free entries still available in the queue. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operation needs to be used with caution because the number of free entries can change unexpectedly. The main intent for using this operation is in conjunction with event deferral. In this case the queue is accessed only from a single thread (by a single AO), so the number of free entries cannot change unexpectedly.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a04e04c02ded69dcd39583107ef4ce299" title="Defer an event to a given separate event queue.">QActive_defer()</a>, <a class="el" href="qf_8h.html#a2dccaa793e2fc549bae183590f5636a2" title="Recall a deferred event from a given event queue.">QActive_recall()</a> </dd></dl>

<p>Definition at line <a class="el" href="qequeue_8h_source.html#l00222">222</a> of file <a class="el" href="qequeue_8h_source.html">qequeue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a54463011114f6b076e0bd62e3fa27102"></a><!-- doxytag: member="qequeue.h::QF_EQUEUE_CTR_SIZE" ref="a54463011114f6b076e0bd62e3fa27102" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_EQUEUE_CTR_SIZE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size (in bytes) of the ring-buffer counters used in the native QF event queue implementation. Valid values: 1, 2, or 4; default 1. </p>
<p>This macro can be defined in the QF port file (<a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C compiler.">qf_port.h</a>) to configure the ::QEQueueCtr type. Here the macro is not defined so the default of 1 byte is chosen. </p>

<p>Definition at line <a class="el" href="qequeue_8h_source.html#l00053">53</a> of file <a class="el" href="qequeue_8h_source.html">qequeue.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae5d5b1feb038085e2922e2f4e45b48a0"></a><!-- doxytag: member="qequeue.h::QEQueue_get" ref="ae5d5b1feb038085e2922e2f4e45b48a0" args="(QEQueue *me)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_event.html">QEvent</a> const* QEQueue_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_e_queue.html">QEQueue</a> *&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"raw" thread-safe QF event queue implementation for the event get operation. </p>
<p>If the queue has one or more events, the function returns the event at the front of the queue, otherwise it returns NULL. You can call this function from any task context or ISR context. Please note that this function uses internally a critical section.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qequeue_8h.html#a1432f9632a6f30c434aea96cc20aa2cf" title="&quot;raw&quot; thread-safe QF event queue implementation for the First-In-First-Out (FIFO) event pos...">QEQueue_postFIFO()</a>, <a class="el" href="qequeue_8h.html#a8ea2e15922ce2e213aa0c27e72cd730a" title="&quot;raw&quot; thread-safe QF event queue implementation for the Last-In-First-Out (LIFO) event post...">QEQueue_postLIFO()</a> </dd></dl>

<p>Definition at line <a class="el" href="qeq__get_8c_source.html#l00041">41</a> of file <a class="el" href="qeq__get_8c_source.html">qeq_get.c</a>.</p>

<p>References <a class="el" href="qevent_8h_source.html#l00152">QEvent::dynamic_</a>, <a class="el" href="qequeue_8h_source.html#l00137">QEQueue::end</a>, <a class="el" href="qequeue_8h_source.html#l00128">QEQueue::frontEvt</a>, <a class="el" href="qequeue_8h_source.html#l00149">QEQueue::nFree</a>, <a class="el" href="qf__pkg_8h_source.html#l00060">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00049">QF_INT_LOCK_KEY_</a>, <a class="el" href="qf__pkg_8h_source.html#l00071">QF_INT_UNLOCK_</a>, <a class="el" href="qs_8h_source.html#l00713">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00725">QS_END_NOLOCK_</a>, <a class="el" href="qs___8c_source.html#l00040">QS_eqObj_</a>, <a class="el" href="qs_8h_source.html#l00752">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00077">QS_QF_EQUEUE_GET</a>, <a class="el" href="qs_8h_source.html#l00078">QS_QF_EQUEUE_GET_LAST</a>, <a class="el" href="qep_8h_source.html#l00286">QS_SIG_</a>, <a class="el" href="qs_8h_source.html#l00730">QS_U8_</a>, <a class="el" href="qequeue_8h_source.html#l00132">QEQueue::ring</a>, <a class="el" href="qevent_8h_source.html#l00151">QEvent::sig</a>, and <a class="el" href="qequeue_8h_source.html#l00145">QEQueue::tail</a>.</p>

</div>
</div>
<a class="anchor" id="abec6b357b489b637afc622b6ee635921"></a><!-- doxytag: member="qequeue.h::QEQueue_init" ref="abec6b357b489b637afc622b6ee635921" args="(QEQueue *me, QEvent const *qSto[], QEQueueCtr qLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QEQueue_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_e_queue.html">QEQueue</a> *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>qSto</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QEQueueCtr&#160;</td>
          <td class="paramname"><em>qLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the native QF event queue. </p>
<p>The parameters are as follows: <em>me</em> points to the <a class="el" href="struct_q_event.html" title="Event structure.">QEvent</a> struct to be initialized, <em>qSto</em>[] is the ring buffer storage, <em>qLen</em> is the length of the ring buffer in the units of event-pointers.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The actual capacity of the queue is qLen + 1, because of the extra location fornEvt. </dd></dl>

<p>Definition at line <a class="el" href="qeq__init_8c_source.html#l00038">38</a> of file <a class="el" href="qeq__init_8c_source.html">qeq_init.c</a>.</p>

<p>References <a class="el" href="qequeue_8h_source.html#l00137">QEQueue::end</a>, <a class="el" href="qequeue_8h_source.html#l00128">QEQueue::frontEvt</a>, <a class="el" href="qequeue_8h_source.html#l00141">QEQueue::head</a>, <a class="el" href="qequeue_8h_source.html#l00149">QEQueue::nFree</a>, <a class="el" href="qequeue_8h_source.html#l00157">QEQueue::nMin</a>, <a class="el" href="qs_8h_source.html#l00691">QS_BEGIN_</a>, <a class="el" href="qs_8h_source.html#l00703">QS_END_</a>, <a class="el" href="qs___8c_source.html#l00040">QS_eqObj_</a>, <a class="el" href="qs_8h_source.html#l00628">QS_INT_LOCK_KEY_</a>, <a class="el" href="qs_8h_source.html#l00752">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00074">QS_QF_EQUEUE_INIT</a>, <a class="el" href="qequeue_8h_source.html#l00132">QEQueue::ring</a>, and <a class="el" href="qequeue_8h_source.html#l00145">QEQueue::tail</a>.</p>

<p>Referenced by <a class="el" href="qk_8c_source.html#l00091">QActive_start()</a>.</p>

</div>
</div>
<a class="anchor" id="a1432f9632a6f30c434aea96cc20aa2cf"></a><!-- doxytag: member="qequeue.h::QEQueue_postFIFO" ref="a1432f9632a6f30c434aea96cc20aa2cf" args="(QEQueue *me, QEvent const *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QEQueue_postFIFO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_e_queue.html">QEQueue</a> *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"raw" thread-safe QF event queue implementation for the First-In-First-Out (FIFO) event posting. You can call this function from any task context or ISR context. Please note that this function uses internally a critical section. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The function raises an assertion if the native QF queue becomes full and cannot accept the event.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qequeue_8h.html#a8ea2e15922ce2e213aa0c27e72cd730a" title="&quot;raw&quot; thread-safe QF event queue implementation for the Last-In-First-Out (LIFO) event post...">QEQueue_postLIFO()</a>, <a class="el" href="qequeue_8h.html#ae5d5b1feb038085e2922e2f4e45b48a0" title="&quot;raw&quot; thread-safe QF event queue implementation for the event get operation.">QEQueue_get()</a> </dd></dl>

<p>Definition at line <a class="el" href="qeq__fifo_8c_source.html#l00041">41</a> of file <a class="el" href="qeq__fifo_8c_source.html">qeq_fifo.c</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00095">Q_ASSERT</a>, <a class="el" href="qf__pkg_8h_source.html#l00060">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00049">QF_INT_LOCK_KEY_</a>, <a class="el" href="qf__pkg_8h_source.html#l00071">QF_INT_UNLOCK_</a>, <a class="el" href="qs_8h_source.html#l00713">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00725">QS_END_NOLOCK_</a>, <a class="el" href="qs___8c_source.html#l00040">QS_eqObj_</a>, <a class="el" href="qs_8h_source.html#l00752">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00075">QS_QF_EQUEUE_POST_FIFO</a>, <a class="el" href="qep_8h_source.html#l00286">QS_SIG_</a>, and <a class="el" href="qs_8h_source.html#l00730">QS_U8_</a>.</p>

</div>
</div>
<a class="anchor" id="a8ea2e15922ce2e213aa0c27e72cd730a"></a><!-- doxytag: member="qequeue.h::QEQueue_postLIFO" ref="a8ea2e15922ce2e213aa0c27e72cd730a" args="(QEQueue *me, QEvent const *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QEQueue_postLIFO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_e_queue.html">QEQueue</a> *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"raw" thread-safe QF event queue implementation for the Last-In-First-Out (LIFO) event posting. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The LIFO policy should be used only with great caution because it alters order of events in the queue. </dd>
<dd>
The function raises an assertion if the native QF queue becomes full and cannot accept the event. You can call this function from any task context or ISR context. Please note that this function uses internally a critical section.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qequeue_8h.html#a1432f9632a6f30c434aea96cc20aa2cf" title="&quot;raw&quot; thread-safe QF event queue implementation for the First-In-First-Out (FIFO) event pos...">QEQueue_postFIFO()</a>, <a class="el" href="qequeue_8h.html#ae5d5b1feb038085e2922e2f4e45b48a0" title="&quot;raw&quot; thread-safe QF event queue implementation for the event get operation.">QEQueue_get()</a> </dd></dl>

<p>Definition at line <a class="el" href="qeq__lifo_8c_source.html#l00041">41</a> of file <a class="el" href="qeq__lifo_8c_source.html">qeq_lifo.c</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00095">Q_ASSERT</a>, <a class="el" href="qf__pkg_8h_source.html#l00060">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00049">QF_INT_LOCK_KEY_</a>, <a class="el" href="qf__pkg_8h_source.html#l00071">QF_INT_UNLOCK_</a>, <a class="el" href="qs_8h_source.html#l00713">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00725">QS_END_NOLOCK_</a>, <a class="el" href="qs___8c_source.html#l00040">QS_eqObj_</a>, <a class="el" href="qs_8h_source.html#l00752">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00076">QS_QF_EQUEUE_POST_LIFO</a>, <a class="el" href="qep_8h_source.html#l00286">QS_SIG_</a>, and <a class="el" href="qs_8h_source.html#l00730">QS_U8_</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Jan 7 2011 21:36:55 for QP/C by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
